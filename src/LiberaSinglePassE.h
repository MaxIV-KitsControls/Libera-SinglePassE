/*----- PROTECTED REGION ID(LiberaSinglePassE.h) ENABLED START -----*/
//=============================================================================
//
// file :        LiberaSinglePassE.h
//
// description : Include for the LiberaSinglePassE class.
//
// project :     Libera Brillance Single Pass E.
//
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL:  $
//
// CVS only:
// $Source:  $
// $Log:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#ifndef LIBERASINGLEPASSE_H
#define LIBERASINGLEPASSE_H

#include <math.h>
#include <tango.h>
#include "LiberaCommon.h"

#include <string.h>

#include <map>
#include <utility>
#include <sstream>


#define			ON_STATUS				"Libera box is up and running"
#define			MAX_BUF_SIZE			10000
#define			MIN_POINTS				5
#define			POINTS_AVERAGING		4
#define			POINTS_PER_US			108
#define			MAX_CURRENT_BUF_SIZE	80

#define CHECK_ALLOC(ptr) \
if (ptr == NULL) \
{ \
	Tango::Except::throw_exception ("LiberaSinglePassE_BadAlloc", \
			"Error while allocating memory", \
			"LiberaSinglePassE::init_device"); \
}

/*----- PROTECTED REGION END -----*/


/**
 *	LiberaSinglePassE class Description:
 *	This Tango class is the interface of the Instrumentation Technologies (IT) Libera
 *	Brilliance Single Pass E equipment. This class supports only a subset of all the
 *	equipment features. It is the basic equipment for a Injection and Transfer Efficiency
 *	Measurement System
 */

namespace LiberaSinglePassE_ns
{
	/*----- PROTECTED REGION ID(LiberaSinglePassE::Additional Class Declarations) ENABLED START -----*/

#define FATAL_STREAM_DS \
	if (get_logger()->is_fatal_enabled()) \
		get_logger()->fatal_stream() \
		<< log4tango::LogInitiator::_begin_log \
		<< __FILE__ << " " << __func__ << "[" << __LINE__ << "] " \
		<< "TDS " << device_name << " "

#define ERROR_STREAM_DS \
	if (get_logger()->is_error_enabled()) \
		get_logger()->error_stream() \
		<< log4tango::LogInitiator::_begin_log \
		<< __FILE__ << " " << __func__ << "[" << __LINE__ << "] " \
		<< "TDS " << device_name << " "

#define WARN_STREAM_DS \
	if (get_logger()->is_warn_enabled()) \
		get_logger()->warn_stream() \
		<< log4tango::LogInitiator::_begin_log \
		<< __FILE__ << " " << __func__ << "[" << __LINE__ << "] " \
		<< "TDS " << device_name << " "

#define INFO_STREAM_DS \
	if (get_logger()->is_info_enabled()) \
		get_logger()->info_stream() \
		<< log4tango::LogInitiator::_begin_log \
		<< __FILE__ << " " << __func__ << "[" << __LINE__ << "] " \
		<< "TDS " << device_name << " "

#define DEBUG_STREAM_DS \
	if (get_logger()->is_debug_enabled()) \
		get_logger()->debug_stream() \
		<< log4tango::LogInitiator::_begin_log \
		<< __FILE__ << " " << __func__ << "[" << __LINE__ << "] " \
		<< "TDS " << device_name << " "

#define ENDLOG_DS \
	log4tango::LogSeparator::_end_log

//		Additional Class Declarations
class LiberaSinglePassEDataTask;

	/*----- PROTECTED REGION END -----*/	//	LiberaSinglePassE::Additional Class Declarations


class LiberaSinglePassE : public Tango::Device_4Impl
{


	/*----- PROTECTED REGION ID(LiberaSinglePassE::Data Members) ENABLED START -----*/

	//		Add your own data members

	/*----- PROTECTED REGION END -----*/	//	LiberaSinglePassE::Data Members


//	Device property data members
public:		//	LiberaIpAddr:	Libera IP address
	string	liberaIpAddr;
	//	LiberaBoard:	The board name (and index) used by the Libera box for multi board setup
	string	liberaBoard;
	//	Location:	The libera box physical place (TL1, BOOSTER,....)
	string	location;
	//	DataTaskHeartbeat:	Heartbeat time (in mS) for the data task
	Tango::DevLong	dataTaskHeartbeat;
	//	BeamThreshold:	Threshold to decide if there is some beam at a given time
	//	(at a given index in the ADC buffers)
	Tango::DevDouble	beamThreshold;
	//	PositionK:	Multiplicative coefficient to compute beam position
	Tango::DevDouble	positionK;
	//	CurrentK:	Multiplicative coefficient to compute beam current
	Tango::DevDouble	currentK;
	//	CurrentTimeOffset:	Time coefficient used in current computation
	Tango::DevLong	currentTimeOffset;


//	Attribute data members
public:
	Tango::DevLong	*attr_BufferSize_read;
	Tango::DevLong	*attr_AttenuationLevel_read;
	Tango::DevULong	*attr_TriggerCounter_read;
	Tango::DevUShort	*attr_Fan1Speed_read;
	Tango::DevUShort	*attr_Fan2Speed_read;
	Tango::DevUShort	*attr_Temp1_read;
	Tango::DevUShort	*attr_Temp2_read;
	Tango::DevUShort	*attr_Temp3_read;
	Tango::DevDouble	*attr_CalibrationKa_read;
	Tango::DevDouble	*attr_CalibrationKb_read;
	Tango::DevDouble	*attr_CalibrationKc_read;
	Tango::DevDouble	*attr_CalibrationKd_read;
	Tango::DevDouble	*attr_LinearXK_read;
	Tango::DevDouble	*attr_LinearXOffs_read;
	Tango::DevDouble	*attr_LinearYK_read;
	Tango::DevDouble	*attr_LinearYOffs_read;
	Tango::DevDouble	*attr_LinearQK_read;
	Tango::DevDouble	*attr_LinearQOffs_read;
	Tango::DevDouble	*attr_LinearSumK_read;
	Tango::DevDouble	*attr_LinearSumOffs_read;
	Tango::DevDouble	*attr_SignalExpansion_read;
	Tango::DevBoolean	*attr_InterlockEnabled_read;
	Tango::DevDouble	*attr_LimitMinX_read;
	Tango::DevDouble	*attr_LimitMinY_read;
	Tango::DevDouble	*attr_LimitMaxX_read;
	Tango::DevDouble	*attr_LimitMaxY_read;
	Tango::DevULong	*attr_OverflowThreshold_read;
	Tango::DevULong	*attr_InterlockStatus_read;
	Tango::DevBoolean	*attr_StatusX_read;
	Tango::DevBoolean	*attr_StatusY_read;
	Tango::DevBoolean	*attr_StatusAdcOverflow_read;
	Tango::DevShort	*attr_A_read;
	Tango::DevShort	*attr_B_read;
	Tango::DevShort	*attr_C_read;
	Tango::DevShort	*attr_D_read;
	Tango::DevDouble	*attr_AT_read;
	Tango::DevDouble	*attr_BT_read;
	Tango::DevDouble	*attr_CT_read;
	Tango::DevDouble	*attr_DT_read;
	Tango::DevDouble	*attr_Yposition_read;
	Tango::DevDouble	*attr_Xposition_read;
	Tango::DevDouble	*attr_Current_read;
	Tango::DevDouble	*attr_SumT_read;



//	Constructors and destructors
public:
	/**
	 * Constructs a newly allocated Command object.
	 *
	 *	@param cl	Class.
	 *	@param s 	Device Name
	 */
	LiberaSinglePassE(Tango::DeviceClass *cl,string &s);
	/**
	 * Constructs a newly allocated Command object.
	 *
	 *	@param cl	Class.
	 *	@param s 	Device Name
	 */
	LiberaSinglePassE(Tango::DeviceClass *cl,const char *s);
	/**
	 * Constructs a newly allocated Command object.
	 *
	 *	@param cl	Class.
	 *	@param s 	Device name
	 *	@param d	Device description.
	 */
	LiberaSinglePassE(Tango::DeviceClass *cl,const char *s,const char *d);
	/**
	 * The object destructor.
	 */
	~LiberaSinglePassE() {delete_device();};



//	Miscellaneous methods
public:
	/**
	 *	will be called at device destruction or at init command.
	 */
	void delete_device();
	/**
	 *	Initialize the device
	 */
	virtual void init_device();
	/**
	 *	Read the device properties from database
	 */
	 void get_device_property();
	/**
	 *	Always executed method before execution command method.
	 */
	virtual void always_executed_hook();


//	Attribute methods
public:
	/**
	 *	Method      : LiberaSinglePassE::read_attr_hardware()
	 *	Description : Hardware acquisition for attributes.
	 */
	virtual void read_attr_hardware(vector<long> &attr_list);


	/**
	 *	BufferSize attribute related methods.
	 *	Description: The Libera box ADC buffer size (between 10 and 8192)
	 *
	 *	Data type:	Tango::DevLong
	 *	Attr type:	Scalar
	 */
	virtual void read_BufferSize(Tango::Attribute &attr);
	virtual void write_BufferSize(Tango::WAttribute &attr);
	virtual bool is_BufferSize_allowed(Tango::AttReqType type);



	/**
	 *	AttenuationLevel attribute related methods.
	 *	Description: Each analogue channel on one processor module in
 *	             Libera Single Pass E has one 5-bit programmable
 *	             attenuator. The attenuation can be controlled in the
 *	             range from 0 to 31dB in steps of 1dB. Gain control serves
 *	             to set the attenuators according to the input RF signal
 *	             level. Writing to this attribute serves to set the input
 *	             RF signal attenuators in dB.
	 *
	 *	Data type:	Tango::DevLong
	 *	Attr type:	Scalar
	 */
	virtual void read_AttenuationLevel(Tango::Attribute &attr);
	virtual void write_AttenuationLevel(Tango::WAttribute &attr);
	virtual bool is_AttenuationLevel_allowed(Tango::AttReqType type);



	/**
	 *	TriggerCounter attribute related methods.
	 *	Description: Trigger counter. Incremented at each trigger
	 *
	 *	Data type:	Tango::DevULong
	 *	Attr type:	Scalar
	 */
	virtual void read_TriggerCounter(Tango::Attribute &attr);
	virtual bool is_TriggerCounter_allowed(Tango::AttReqType type);



	/**
	 *	Fan1Speed attribute related methods.
<<<<<<< HEAD
     *	Description: Provides minimal fan speed reading of all three fans on
=======
	 *	Description: Provides minimal fan speed reading of all three� fans on
>>>>>>> c67445acda0196ffcd05861097d1d44451f8490f
 *	             the left side of the chassis in order to identify if the fan
 *	             module (consisting of 3 fans) is broken - returned value
 *	             0 means that at least one fan has stopped.
	 *
	 *	Data type:	Tango::DevUShort
	 *	Attr type:	Scalar
	 */
	virtual void read_Fan1Speed(Tango::Attribute &attr);
	virtual bool is_Fan1Speed_allowed(Tango::AttReqType type);



	/**
	 *	Fan2Speed attribute related methods.
<<<<<<< HEAD
     *	Description: Provides minimal fan speed reading of all three fans on
=======
	 *	Description: Provides minimal fan speed reading of all three� fans on
>>>>>>> c67445acda0196ffcd05861097d1d44451f8490f
 *	             the right side of the chassis in order to identify if the
 *	             fan module (consisting of 3 fans) is broken - returned
 *	             value 0 means that at least one fan has stopped.
	 *
	 *	Data type:	Tango::DevUShort
	 *	Attr type:	Scalar
	 */
	virtual void read_Fan2Speed(Tango::Attribute &attr);
	virtual bool is_Fan2Speed_allowed(Tango::AttReqType type);



	/**
	 *	Temp1 attribute related methods.
	 *	Description: Temperature of the hottest component on the BPM
 *	             module is returned.
	 *
	 *	Data type:	Tango::DevUShort
	 *	Attr type:	Scalar
	 */
	virtual void read_Temp1(Tango::Attribute &attr);
	virtual bool is_Temp1_allowed(Tango::AttReqType type);



	/**
	 *	Temp2 attribute related methods.
	 *	Description: Temperature of the hottest component on the chassis
 *	             interconnection board is returned.
	 *
	 *	Data type:	Tango::DevUShort
	 *	Attr type:	Scalar
	 */
	virtual void read_Temp2(Tango::Attribute &attr);
	virtual bool is_Temp2_allowed(Tango::AttReqType type);



	/**
	 *	Temp3 attribute related methods.
	 *	Description: Temperature of the hottest component on the timing
 *	             module is returned.
	 *
	 *	Data type:	Tango::DevUShort
	 *	Attr type:	Scalar
	 */
	virtual void read_Temp3(Tango::Attribute &attr);
	virtual bool is_Temp3_allowed(Tango::AttReqType type);



	/**
	 *	CalibrationKa attribute related methods.
	 *	Description: Correction coefficient of the pickup sensor for channel A.
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Scalar
	 */
	virtual void read_CalibrationKa(Tango::Attribute &attr);
	virtual void write_CalibrationKa(Tango::WAttribute &attr);
	virtual bool is_CalibrationKa_allowed(Tango::AttReqType type);



	/**
	 *	CalibrationKb attribute related methods.
	 *	Description: Correction coefficient of the pickup sensor for channel B.
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Scalar
	 */
	virtual void read_CalibrationKb(Tango::Attribute &attr);
	virtual void write_CalibrationKb(Tango::WAttribute &attr);
	virtual bool is_CalibrationKb_allowed(Tango::AttReqType type);



	/**
	 *	CalibrationKc attribute related methods.
	 *	Description: Correction coefficient of the pickup sensor for channel C.
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Scalar
	 */
	virtual void read_CalibrationKc(Tango::Attribute &attr);
	virtual void write_CalibrationKc(Tango::WAttribute &attr);
	virtual bool is_CalibrationKc_allowed(Tango::AttReqType type);



	/**
	 *	CalibrationKd attribute related methods.
	 *	Description: Correction coefficient of the pickup sensor for channel D.
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Scalar
	 */
	virtual void read_CalibrationKd(Tango::Attribute &attr);
	virtual void write_CalibrationKd(Tango::WAttribute &attr);
	virtual bool is_CalibrationKd_allowed(Tango::AttReqType type);



	/**
	 *	LinearXK attribute related methods.
	 *	Description: Setting the correction coefficient of the linear equation
 *	             for the x position calculation. See chapter 2.6.1 in
 *	             Libera Single Pass E User manual for details.
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Scalar
	 */
	virtual void read_LinearXK(Tango::Attribute &attr);
	virtual void write_LinearXK(Tango::WAttribute &attr);
	virtual bool is_LinearXK_allowed(Tango::AttReqType type);



	/**
	 *	LinearXOffs attribute related methods.
	 *	Description: Used to calibrate position offsets expressed in nm.
 *	             Please refer to Chapter 2.6 in Libera Single Pass E
 *	             User manual for details.
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Scalar
	 */
	virtual void read_LinearXOffs(Tango::Attribute &attr);
	virtual void write_LinearXOffs(Tango::WAttribute &attr);
	virtual bool is_LinearXOffs_allowed(Tango::AttReqType type);



	/**
	 *	LinearYK attribute related methods.
	 *	Description: Setting the correction coefficient of the linear equation
 *	             for the y position calculation. See chapter 2.6.1 in
 *	             Libera Single Pass E User manual for details.
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Scalar
	 */
	virtual void read_LinearYK(Tango::Attribute &attr);
	virtual void write_LinearYK(Tango::WAttribute &attr);
	virtual bool is_LinearYK_allowed(Tango::AttReqType type);



	/**
	 *	LinearYOffs attribute related methods.
	 *	Description: Used to calibrate position offsets expressed in nm.
 *	             Please refer to Chapter 2.6 in Libera Single Pass E
 *	             User manual for details.
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Scalar
	 */
	virtual void read_LinearYOffs(Tango::Attribute &attr);
	virtual void write_LinearYOffs(Tango::WAttribute &attr);
	virtual bool is_LinearYOffs_allowed(Tango::AttReqType type);



	/**
	 *	LinearQK attribute related methods.
	 *	Description: Setting the correction coefficient of the linear equation
 *	             for the q calculation. See chapter 2.6.1 in Libera Single
 *	             Pass E User manual for details.
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Scalar
	 */
	virtual void read_LinearQK(Tango::Attribute &attr);
	virtual void write_LinearQK(Tango::WAttribute &attr);
	virtual bool is_LinearQK_allowed(Tango::AttReqType type);



	/**
	 *	LinearQOffs attribute related methods.
	 *	Description: Sets the offset for q factor. Default value is 0.
 *	             See Chapter 2.6 in Libera Single Pass E User manual
 *	             for details.
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Scalar
	 */
	virtual void read_LinearQOffs(Tango::Attribute &attr);
	virtual void write_LinearQOffs(Tango::WAttribute &attr);
	virtual bool is_LinearQOffs_allowed(Tango::AttReqType type);



	/**
	 *	LinearSumK attribute related methods.
	 *	Description: Coefficient for sum value. Default is 67108864 (2^26).
 *	             Please refer to Chapter 2.6 in the Libera Single Pass E
 *	             User manual for details.
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Scalar
	 */
	virtual void read_LinearSumK(Tango::Attribute &attr);
	virtual void write_LinearSumK(Tango::WAttribute &attr);
	virtual bool is_LinearSumK_allowed(Tango::AttReqType type);



	/**
	 *	LinearSumOffs attribute related methods.
	 *	Description: Coefficient for offsetting the sum value.
 *	             Default value is 0. Please refer to Chapter 2.6 of Libera
 *	             Single Pass E User manual for details.
 *
 *	             NOTE: The Libera Single Pass E has the possibility to
 *	             support also the polynomial equations for calculation
 *	             of position, however it is not supported in Tango as the
 *	             Libera Brilliance Single Pass supports only the linear
 *	             equation. Polynomial equation is providing more
 *	             accurate results of measurements as it is
 *	             compensating for the nonlinear anomalies for the
 *	             pick-up sensor. Please see the chapter 2.6.2 in the
 *	             Libera Single Pass E user manual for details.
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Scalar
	 */
	virtual void read_LinearSumOffs(Tango::Attribute &attr);
	virtual void write_LinearSumOffs(Tango::WAttribute &attr);
	virtual bool is_LinearSumOffs_allowed(Tango::AttReqType type);



	/**
	 *	SignalExpansion attribute related methods.
	 *	Description: Interlock output is active for all the time the Interlock
 *	             conditions are fulfilled (ADC overflow and position
 *	             monitoring). The Interlock output remains active for a
 *	             certain time after the conditions have been cleared
 *	             (mono-stable cell). The time is defined in ADC clock
 *	             cycles with ireg parameter signal_expansion.
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Scalar
	 */
	virtual void read_SignalExpansion(Tango::Attribute &attr);
	virtual void write_SignalExpansion(Tango::WAttribute &attr);
	virtual bool is_SignalExpansion_allowed(Tango::AttReqType type);



	/**
	 *	InterlockEnabled attribute related methods.
	 *	Description: Enables/disables the interlock functionality. If it is set to
 *	             true, interlock is enabled, if set to false, interlock is
 *	             disabled. More details are in the chapter 2.12 in the
 *	             Libera Single Pass E User manual.
	 *
	 *	Data type:	Tango::DevBoolean
	 *	Attr type:	Scalar
	 */
	virtual void read_InterlockEnabled(Tango::Attribute &attr);
	virtual void write_InterlockEnabled(Tango::WAttribute &attr);
	virtual bool is_InterlockEnabled_allowed(Tango::AttReqType type);



	/**
	 *	LimitMinX attribute related methods.
	 *	Description: Interlock lower limit parameter for x position in nm.
 *	             See Chapter 2.12.1 in the Libera Single Pass E User
 *	             manual for details.
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Scalar
	 */
	virtual void read_LimitMinX(Tango::Attribute &attr);
	virtual void write_LimitMinX(Tango::WAttribute &attr);
	virtual bool is_LimitMinX_allowed(Tango::AttReqType type);



	/**
	 *	LimitMinY attribute related methods.
	 *	Description: Interlock lower limit parameter for y position in nm.
 *	             See Chapter 2.12.1 in the Libera Single Pass E User
 *	             manual for details.
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Scalar
	 */
	virtual void read_LimitMinY(Tango::Attribute &attr);
	virtual void write_LimitMinY(Tango::WAttribute &attr);
	virtual bool is_LimitMinY_allowed(Tango::AttReqType type);



	/**
	 *	LimitMaxX attribute related methods.
	 *	Description: Interlock upper limit parameter for x position in nm.
 *	             See Chapter 2.12.1 in the Libera Single Pass E User
 *	             manual for details.
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Scalar
	 */
	virtual void read_LimitMaxX(Tango::Attribute &attr);
	virtual void write_LimitMaxX(Tango::WAttribute &attr);
	virtual bool is_LimitMaxX_allowed(Tango::AttReqType type);



	/**
	 *	LimitMaxY attribute related methods.
	 *	Description: Interlock upper limit parameter for y position in nm.
 *	             See Chapter 2.12.1 in the Libera Single Pass E User
 *	             manual for details.
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Scalar
	 */
	virtual void read_LimitMaxY(Tango::Attribute &attr);
	virtual void write_LimitMaxY(Tango::WAttribute &attr);
	virtual bool is_LimitMaxY_allowed(Tango::AttReqType type);



	/**
	 *	OverflowThreshold attribute related methods.
	 *	Description: Interlock upper limit parameter for the ADC overflow
 *	             buffer (ADC saturation) parameter which is in ADC
 *	             counts. See Chapter 2.12.2 in the Libera Single Pass E
 *	             User manual for details.
	 *
	 *	Data type:	Tango::DevULong
	 *	Attr type:	Scalar
	 */
	virtual void read_OverflowThreshold(Tango::Attribute &attr);
	virtual void write_OverflowThreshold(Tango::WAttribute &attr);
	virtual bool is_OverflowThreshold_allowed(Tango::AttReqType type);



	/**
	 *	InterlockStatus attribute related methods.
	 *	Description: Issuing this command tells you which was the cause of
 *	             the interlock. Number is 5 bit expressed in the decimal
 *	             value. If no interlock was triggered, the returned value
 *	             is 0. See the chapter 2.12.3 in the Libera Single Pass E
 *	             User manual for details.
	 *
	 *	Data type:	Tango::DevULong
	 *	Attr type:	Scalar
	 */
	virtual void read_InterlockStatus(Tango::Attribute &attr);
	virtual bool is_InterlockStatus_allowed(Tango::AttReqType type);



	/**
	 *	StatusX attribute related methods.
	 *	Description: Checking the status of the interlock for the x position.
 *	             Returned value 'false' means that x position wasn't out
 *	             of set limit.
	 *
	 *	Data type:	Tango::DevBoolean
	 *	Attr type:	Scalar
	 */
	virtual void read_StatusX(Tango::Attribute &attr);
	virtual bool is_StatusX_allowed(Tango::AttReqType type);



	/**
	 *	StatusY attribute related methods.
	 *	Description: Checking the status of the interlock for the y position.
 *	             Returned value 'false' means that y position wasn't out
 *	             of set limit.
	 *
	 *	Data type:	Tango::DevBoolean
	 *	Attr type:	Scalar
	 */
	virtual void read_StatusY(Tango::Attribute &attr);
	virtual bool is_StatusY_allowed(Tango::AttReqType type);



	/**
	 *	StatusAdcOverflow attribute related methods.
	 *	Description: Checking the status of the interlock for the ADC
 *	             saturation. Returned value 'false' means that ADC
 *	             wasn't in saturation.
	 *
	 *	Data type:	Tango::DevBoolean
	 *	Attr type:	Scalar
	 */
	virtual void read_StatusAdcOverflow(Tango::Attribute &attr);
	virtual bool is_StatusAdcOverflow_allowed(Tango::AttReqType type);



	/**
	 *	A attribute related methods.
	 *	Description: The A StripLine ADC buffer
	 *
	 *	Data type:	Tango::DevShort
	 *	Attr type:	Spectrum  max = 10000
	 */
	virtual void read_A(Tango::Attribute &attr);
	virtual bool is_A_allowed(Tango::AttReqType type);



	/**
	 *	B attribute related methods.
	 *	Description: The B StripLine ADC buffer
	 *
	 *	Data type:	Tango::DevShort
	 *	Attr type:	Spectrum  max = 10000
	 */
	virtual void read_B(Tango::Attribute &attr);
	virtual bool is_B_allowed(Tango::AttReqType type);



	/**
	 *	C attribute related methods.
	 *	Description: The C StripLine ADC buffer
	 *
	 *	Data type:	Tango::DevShort
	 *	Attr type:	Spectrum  max = 10000
	 */
	virtual void read_C(Tango::Attribute &attr);
	virtual bool is_C_allowed(Tango::AttReqType type);



	/**
	 *	D attribute related methods.
	 *	Description: The D StripLine ADC buffer
	 *
	 *	Data type:	Tango::DevShort
	 *	Attr type:	Spectrum  max = 10000
	 */
	virtual void read_D(Tango::Attribute &attr);
	virtual bool is_D_allowed(Tango::AttReqType type);



	/**
	 *	AT attribute related methods.
	 *	Description: The A StripLine ADC buffer after some computation:
 *	             square - double averaging filter - square root
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Spectrum  max = 10000
	 */
	virtual void read_AT(Tango::Attribute &attr);
	virtual bool is_AT_allowed(Tango::AttReqType type);



	/**
	 *	BT attribute related methods.
	 *	Description: The B StripLine ADC buffer after some computation:
 *	             square - double averaging filter - square root
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Spectrum  max = 10000
	 */
	virtual void read_BT(Tango::Attribute &attr);
	virtual bool is_BT_allowed(Tango::AttReqType type);



	/**
	 *	CT attribute related methods.
	 *	Description: The C StripLine ADC buffer after some computation:
 *	             square - double averaging filter - square root
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Spectrum  max = 10000
	 */
	virtual void read_CT(Tango::Attribute &attr);
	virtual bool is_CT_allowed(Tango::AttReqType type);



	/**
	 *	DT attribute related methods.
	 *	Description: The D StripLine ADC buffer after some computation:
 *	             square - double averaging filter - square root
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Spectrum  max = 10000
	 */
	virtual void read_DT(Tango::Attribute &attr);
	virtual bool is_DT_allowed(Tango::AttReqType type);



	/**
	 *	Yposition attribute related methods.
	 *	Description: Beam Y position (vertical)
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Spectrum  max = 10000
	 */
	virtual void read_Yposition(Tango::Attribute &attr);
	virtual bool is_Yposition_allowed(Tango::AttReqType type);



	/**
	 *	Xposition attribute related methods.
	 *	Description: Beam X position (horizontal)
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Spectrum  max = 10000
	 */
	virtual void read_Xposition(Tango::Attribute &attr);
	virtual bool is_Xposition_allowed(Tango::AttReqType type);



	/**
	 *	Current attribute related methods.
	 *	Description: Beam current computed from strip lines data
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Spectrum  max = 100
	 */
	virtual void read_Current(Tango::Attribute &attr);
	virtual bool is_Current_allowed(Tango::AttReqType type);



	/**
	 *	SumT attribute related methods.
	 *	Description: Sum of the 4 computed ADC outputs (the xxxT attributes)
	 *
	 *	Data type:	Tango::DevDouble
	 *	Attr type:	Spectrum  max = 10000
	 */
	virtual void read_SumT(Tango::Attribute &attr);
	virtual bool is_SumT_allowed(Tango::AttReqType type);



	/**
	 *	Method      : LiberaSinglePassE::add_dynamic_attributes()
	 *	Description : Add dynamic attributes if any.
	 */
		void add_dynamic_attributes();

//	Command related methods
public:


	/**
	 *	Command Reset related methods.
	 */
	void reset();
	virtual bool is_Reset_allowed(const CORBA::Any &any);

	/**
	 *	Command ResetTrigger related methods.
	 */
	void reset_trigger();
	virtual bool is_ResetTrigger_allowed(const CORBA::Any &any);

	/**
	 *	Command ResetInterlockStatus related methods.
	 */
	void reset_interlock_status();
	virtual bool is_ResetInterlockStatus_allowed(const CORBA::Any &any);

	/**
	 *	Command MagicCommand related methods.
	 */
	Tango::DevVarStringArray *magic_command(Tango::DevString argin);
	virtual bool is_MagicCommand_allowed(const CORBA::Any &any);



	/*----- PROTECTED REGION ID(LiberaSinglePassE::Additional Method prototypes) ENABLED START -----*/

	//	Additional Method prototypes
protected:
	mci::Node mci_application_root;
	mci::Node mci_platform_root;

	/* Application daemon nodes */
	mci::Node mci_Calibration_ka;
	mci::Node mci_Calibration_kb;
	mci::Node mci_Calibration_kc;
	mci::Node mci_Calibration_kd;
	mci::Node mci_Linear_x_k;
	mci::Node mci_Linear_x_offs;
	mci::Node mci_Linear_y_k;
	mci::Node mci_Linear_y_offs;
	mci::Node mci_Linear_q_k;
	mci::Node mci_Linear_q_offs;
	mci::Node mci_Linear_sum_k;
	mci::Node mci_Linear_sum_offs;
	mci::Node mci_SignalExpansion;
	mci::Node mci_InterlockEnabled;
	mci::Node mci_LimitMinX;
	mci::Node mci_LimitMinY;
	mci::Node mci_LimitMaxX;
	mci::Node mci_LimitMaxY;
	mci::Node mci_OverflowThreshold;
	mci::Node mci_InterlockStatus;
	mci::Node mci_InterlockStatusX;
	mci::Node mci_InterlockStatusY;
	mci::Node mci_InterlockStatusADCOverflow;
	mci::Node mci_InterlockStatusTimestamp;
	mci::Node mci_InterlockStatusReset;
	mci::Node mci_LevelNodeGet;
	mci::Node mci_adc_signal;
	mci::Node mci_LevelNodeSet;

	/* Level enumeration node */
	mci::Node mci_level_gt;

	std::map<uint32_t, string> level_enumeration;


	/* Platform daemon nodes */
	mci::Node mci_temp1;
	mci::Node mci_temp2;
	mci::Node mci_temp3;
	mci::Node mci_fan_left_front;
	mci::Node mci_fan_left_rear;
	mci::Node mci_fan_left_middle;
	mci::Node mci_fan_right_front;
	mci::Node mci_fan_right_middle;
	mci::Node mci_fan_right_rear;


	LiberaSinglePassEDataTask *data_thread;

	struct timeval now;

	void compute();
	void compute_T_attr(Tango::DevShort *,Tango::DevDouble *);
	void compute_pos_attr();
	void compute_current_attr();
	void dump_mci_tree(const mci::Node &node, Tango::DevVarStringArray *store, CORBA::ULong *count);

public:
	time_t heartbeat_sec;
	Tango::DevULong trig_ctr;
	Tango::DevULong old_trig_ctr;
	int computed_buf_size;
	int current_buf_size;

	/*----- PROTECTED REGION END -----*/	//	LiberaSinglePassE::Additional Method prototypes

};

	/*----- PROTECTED REGION ID(LiberaSinglePassE::Additional Classes Definitions) ENABLED START -----*/

	//	Additional Classes definitions

	/*----- PROTECTED REGION END -----*/	//	LiberaSinglePassE::Additional Classes Definitions

} //	namespace

#endif	//	LIBERASINGLEPASSE_H
