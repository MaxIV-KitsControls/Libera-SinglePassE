/*----- PROTECTED REGION ID(LiberaSinglePassEClass.cpp) ENABLED START -----*/
static const char *RcsId      = "$Id:  $";
static const char *TagName    = "$Name:  $";
static const char *CvsPath    = "$Source:  $";
static const char *SvnPath    = "$HeadURL:  $";
static const char *HttpServer = "http://www.esrf.eu/computing/cs/tango/tango_doc/ds_doc/";
//=============================================================================
//
// file :        LiberaSinglePassEClass.cpp
//
// description : C++ source for the LiberaSinglePassEClass. A singleton
//               class derived from DeviceClass. It implements the
//               command list and all properties and methods required
//               by the �name� once per process.
//
// project :     Libera Brillance Single Pass E.
//
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL:  $
//
// CVS only:
// $Source:  $
// $Log:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <LiberaSinglePassEClass.h>

/*----- PROTECTED REGION END -----*/

//-------------------------------------------------------------------
/**
 *	Create LiberaSinglePassEClass singleton and
 *	return it in a C function for Python usage
 */
//-------------------------------------------------------------------
extern "C" {
#ifdef _TG_WINDOWS_

__declspec(dllexport)

#endif

	Tango::DeviceClass *_create_LiberaSinglePassE_class(const char *name) {
		return LiberaSinglePassE_ns::LiberaSinglePassEClass::init(name);
	}
}


namespace LiberaSinglePassE_ns
{


//===================================================================
//	Initialize pointer for singleton pattern
//===================================================================
LiberaSinglePassEClass *LiberaSinglePassEClass::_instance = NULL;

//--------------------------------------------------------
/**
 * method : 		LiberaSinglePassEClass::LiberaSinglePassEClass(string &s)
 * description : 	constructor for the LiberaSinglePassEClass
 *
 * @param s	The class name
 */
//--------------------------------------------------------
LiberaSinglePassEClass::LiberaSinglePassEClass(string &s):DeviceClass(s)
{
	cout2 << "Entering LiberaSinglePassEClass constructor" << endl;
	set_default_property();
	get_class_property();
	write_class_property();

	/*----- PROTECTED REGION ID(LiberaSinglePassE::Class::constructor) ENABLED START -----*/

	/*----- PROTECTED REGION END -----*/	//	LiberaSinglePassE::Class::constructor

	cout2 << "Leaving LiberaSinglePassEClass constructor" << endl;
}


//--------------------------------------------------------
/**
 * method : 		LiberaSinglePassEClass::~LiberaSinglePassEClass()
 * description : 	destructor for the LiberaSinglePassEClass
 */
//--------------------------------------------------------
LiberaSinglePassEClass::~LiberaSinglePassEClass()
{
	/*----- PROTECTED REGION ID(LiberaSinglePassE::Class::destructor) ENABLED START -----*/

	/*----- PROTECTED REGION END -----*/	//	LiberaSinglePassE::Class::destructor

	_instance = NULL;
}


//--------------------------------------------------------
/**
 * method : 		LiberaSinglePassEClass::init
 * description : 	Create the object if not already done.
 *                  Otherwise, just return a pointer to the object
 *
 * @param	name	The class name
 */
//--------------------------------------------------------
LiberaSinglePassEClass *LiberaSinglePassEClass::init(const char *name)
{
	if (_instance == NULL)
	{
		try
		{
			string s(name);
			_instance = new LiberaSinglePassEClass(s);
		}
		catch (bad_alloc)
		{
			throw;
		}
	}
	return _instance;
}

//--------------------------------------------------------
/**
 * method : 		LiberaSinglePassEClass::instance
 * description : 	Check if object already created,
 *                  and return a pointer to the object
 */
//--------------------------------------------------------
LiberaSinglePassEClass *LiberaSinglePassEClass::instance()
{
	if (_instance == NULL)
	{
		cerr << "Class is not initialised !!" << endl;
		exit(-1);
	}
	return _instance;
}




//===================================================================
//	Command execution method calls
//===================================================================
//--------------------------------------------------------
/**
 * method : 		ResetClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ResetClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "ResetClass::execute(): arrived" << endl;


	((static_cast<LiberaSinglePassE *>(device))->reset());
	return new CORBA::Any();
}
//--------------------------------------------------------
/**
 * method : 		ResetTriggerClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ResetTriggerClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "ResetTriggerClass::execute(): arrived" << endl;


	((static_cast<LiberaSinglePassE *>(device))->reset_trigger());
	return new CORBA::Any();
}
//--------------------------------------------------------
/**
 * method : 		ResetInterlockStatusClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ResetInterlockStatusClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "ResetInterlockStatusClass::execute(): arrived" << endl;


	((static_cast<LiberaSinglePassE *>(device))->reset_interlock_status());
	return new CORBA::Any();
}
//--------------------------------------------------------
/**
 * method : 		MagicCommandClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *MagicCommandClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "MagicCommandClass::execute(): arrived" << endl;

	Tango::DevString	argin;
	extract(in_any, argin);
	return insert((static_cast<LiberaSinglePassE *>(device))->magic_command(argin));
}




//===================================================================
//	Properties management
//===================================================================

//--------------------------------------------------------
/**
 * method : 		LiberaSinglePassEClass::get_class_property
 * description : 	Get the class property for specified name.
 *
 * @param	name  The property name
 */
//--------------------------------------------------------
Tango::DbDatum LiberaSinglePassEClass::get_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_prop.size() ; i++)
		if (cl_prop[i].name == prop_name)
			return cl_prop[i];
	//	if not found, returns  an empty DbDatum
	return Tango::DbDatum(prop_name);
}


//--------------------------------------------------------
/**
 *	Method      : LiberaSinglePassE::LiberaSinglePassEClass::get_default_device_property()()
 *	Description : Return the default value for device property.
 */
//--------------------------------------------------------
Tango::DbDatum LiberaSinglePassEClass::get_default_device_property(string &prop_name)
{
	for (unsigned int i=0 ; i<dev_def_prop.size() ; i++)
		if (dev_def_prop[i].name == prop_name)
			return dev_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}


//--------------------------------------------------------
/**
 *	Method      : LiberaSinglePassE::LiberaSinglePassEClass::get_default_class_property()()
 *	Description : Return the default value for class property.
 */
//--------------------------------------------------------
Tango::DbDatum LiberaSinglePassEClass::get_default_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_def_prop.size() ; i++)
		if (cl_def_prop[i].name == prop_name)
			return cl_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}


//--------------------------------------------------------
/**
 *	Method      : LiberaSinglePassE::LiberaSinglePassEClass::get_class_property()
 *	Description : //	Add your own code to initialize
 */
//--------------------------------------------------------
void LiberaSinglePassEClass::get_class_property()
{
	/*----- PROTECTED REGION ID(LiberaSinglePassE::Class::get_class_property_before) ENABLED START -----*/

	//	Initialize class property data members

	/*----- PROTECTED REGION END -----*/	//	LiberaSinglePassE::Class::get_class_property_before

	//	Read class properties from database.
	cl_prop.push_back(Tango::DbDatum("DataTaskHeartbeat"));

	if (cl_prop.size()==0) return;	//	No property to read

	//	Call database and extract values
	if (Tango::Util::instance()->_UseDb==true)
		get_db_class()->get_property(cl_prop);
	Tango::DbDatum	def_prop;
	int	i = -1;

	//	Try to extract DataTaskHeartbeat value
	if (cl_prop[++i].is_empty()==false)	cl_prop[i]  >>  dataTaskHeartbeat;
	else
	{
		//	Check default value for DataTaskHeartbeat
		def_prop = get_default_class_property(cl_prop[i].name);
		if (def_prop.is_empty()==false)
		{
			def_prop    >>  dataTaskHeartbeat;
			cl_prop[i]  <<  dataTaskHeartbeat;
		}
	}

	/*----- PROTECTED REGION ID(LiberaSinglePassE::Class::get_class_property_after) ENABLED START -----*/

	//	Check class property data members init

	/*----- PROTECTED REGION END -----*/	//	LiberaSinglePassE::Class::get_class_property_after

}


//--------------------------------------------------------
/**
 *	Method      : LiberaSinglePassE::LiberaSinglePassEClass::set_default_property()
 *	Description : Set default property (class and device) for wizard.
 *	              For each property, add to wizard property name and description.
 *	              If default value has been set, add it to wizard property and.
 *	              store it in a DbDatum.
 */
//--------------------------------------------------------
void LiberaSinglePassEClass::set_default_property()
{
	string	prop_name;
	string	prop_desc;
	string	prop_def;
	vector<string>	vect_data;

	//	Set Default Class Properties
	prop_name = "DataTaskHeartbeat";
	prop_desc = "Heartbeat time (in mS) for the data task";
	prop_def  = "2000`\n";
	vect_data.clear();
	vect_data.push_back("2000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		cl_def_prop.push_back(data);
		add_wiz_class_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_class_prop(prop_name, prop_desc);

	//	Set Default Device Properties

	prop_name = "LiberaIpAddr";
	prop_desc = "Libera IP address";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "LiberaBoard";
	prop_desc = "The board name (and index) used by the Libera box for multi board setup";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "Location";
	prop_desc = "The libera box physical place (TL1, BOOSTER,....)";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "DataTaskHeartbeat";
	prop_desc = "Heartbeat time (in mS) for the data task";
	prop_def  = "2000\n";
	vect_data.clear();
	vect_data.push_back("2000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "BeamThreshold";
	prop_desc = "Threshold to decide if there is some beam at a given time  (at a given index in the ADC buffers)";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "PositionK";
	prop_desc = "Multiplicative coefficient to compute beam position";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "CurrentK";
	prop_desc = "Multiplicative coefficient to compute beam current";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "CurrentTimeOffset";
	prop_desc = "Time coefficient used in current computation";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
}


//--------------------------------------------------------
/**
 *	Method      : LiberaSinglePassE::LiberaSinglePassEClass::write_class_property()
 *	Description : Set class description fields as property in database
 */
//--------------------------------------------------------
void LiberaSinglePassEClass::write_class_property()
{
	//	First time, check if database used
	if (Tango::Util::_UseDb == false)
		return;

	Tango::DbData	data;
	string	classname = get_name();
	string	header;
	string::size_type	start, end;

	//	Put title
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("Libera Brillance Single Pass E");
	title << str_title;
	data.push_back(title);

	//	Put Description
	Tango::DbDatum	description("Description");
	vector<string>	str_desc;
	str_desc.push_back("This Tango class is the interface of the Instrumentation Technologies (IT) Libera");
	str_desc.push_back("Brilliance Single Pass E equipment. This class supports only a subset of all the");
	str_desc.push_back("equipment features. It is the basic equipment for a Injection and Transfer Efficiency");
	str_desc.push_back("Measurement System");
	description << str_desc;
	data.push_back(description);

	//	put cvs or svn location
	string	filename("LiberaSinglePassE");
	filename += "Class.cpp";

	// check for cvs information
	string	src_path(CvsPath);
	start = src_path.find("/");
	if (start!=string::npos)
	{
		end   = src_path.find(filename);
		if (end>start)
		{
			string	strloc = src_path.substr(start, end-start);
			//	Check if specific repository
			start = strloc.find("/cvsroot/");
			if (start!=string::npos && start>0)
			{
				string	repository = strloc.substr(0, start);
				if (repository.find("/segfs/")!=string::npos)
					strloc = "ESRF:" + strloc.substr(start, strloc.length()-start);
			}
			Tango::DbDatum	cvs_loc("cvs_location");
			cvs_loc << strloc;
			data.push_back(cvs_loc);
		}
	}
	// check for svn information
	else
	{
		string	src_path(SvnPath);
		start = src_path.find("://");
		if (start!=string::npos)
		{
			end = src_path.find(filename);
			if (end>start)
			{
				header = "$HeadURL: ";
				start = header.length();
				string	strloc = src_path.substr(start, (end-start));

				Tango::DbDatum	svn_loc("svn_location");
				svn_loc << strloc;
				data.push_back(svn_loc);
			}
		}
	}

	//	Get CVS or SVN revision tag

	// CVS tag
	string	tagname(TagName);
	header = "$Name: ";
	start = header.length();
	string	endstr(" $");

	end   = tagname.find(endstr);
	if (end!=string::npos && end>start)
	{
		string	strtag = tagname.substr(start, end-start);
		Tango::DbDatum	cvs_tag("cvs_tag");
		cvs_tag << strtag;
		data.push_back(cvs_tag);
	}

	// SVN tag
	string	svnpath(SvnPath);
	header = "$HeadURL: ";
	start = header.length();

	end   = svnpath.find(endstr);
	if (end!=string::npos && end>start)
	{
		string	strloc = svnpath.substr(start, end-start);

		string tagstr ("/tags/");
		start = strloc.find(tagstr);
		if ( start!=string::npos )
		{
			start = start + tagstr.length();
			end   = strloc.find(filename);
			string	strtag = strloc.substr(start, end-start-1);

			Tango::DbDatum	svn_tag("svn_tag");
			svn_tag << strtag;
			data.push_back(svn_tag);
		}
	}

	//	Get URL location
	string	httpServ(HttpServer);
	if (httpServ.length()>0)
	{
		Tango::DbDatum	db_doc_url("doc_url");
		db_doc_url << httpServ;
		data.push_back(db_doc_url);
	}

	//  Put inheritance
	Tango::DbDatum	inher_datum("InheritedFrom");
	vector<string> inheritance;
	inheritance.push_back("Device_4Impl");
	inher_datum << inheritance;
	data.push_back(inher_datum);

	//	Call database and and values
	get_db_class()->put_property(data);
}




//===================================================================
//	Factory methods
//===================================================================


//--------------------------------------------------------
/**
 * method : 		LiberaSinglePassEClass::device_factory
 * description : 	Create the device object(s)
 *                  and store them in the device list
 *
 * @param	*devlist_ptr	The device name list
 */
//--------------------------------------------------------
void LiberaSinglePassEClass::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{

	/*----- PROTECTED REGION ID(LiberaSinglePassE::Class::device_factory_before) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	LiberaSinglePassE::Class::device_factory_before

	//	Create devices and add it into the device list
	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
		device_list.push_back(new LiberaSinglePassE(this, (*devlist_ptr)[i]));
	}

	//	Manage dynamic attributes if any
	erase_dynamic_attributes(devlist_ptr, get_class_attr()->get_attr_list());

	//	Export devices to the outside world
	for (unsigned long i=1 ; i<=devlist_ptr->length() ; i++)
	{
		//	Add dynamic attributes if any
		LiberaSinglePassE *dev = static_cast<LiberaSinglePassE *>(device_list[device_list.size()-i]);
		dev->add_dynamic_attributes();

		//	Check before if database used.
		if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
			export_device(dev);
		else
			export_device(dev, dev->get_name().c_str());
	}

	/*----- PROTECTED REGION ID(LiberaSinglePassE::Class::device_factory_after) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	LiberaSinglePassE::Class::device_factory_after


}


//--------------------------------------------------------
/**
 *	Method      : LiberaSinglePassE::LiberaSinglePassEClass::attribute_factory()
 *	Description : Create the attribute object(s)
 *	              and store them in the attribute list
 */
//--------------------------------------------------------
void LiberaSinglePassEClass::attribute_factory(vector<Tango::Attr *> &att_list)
{
	/*----- PROTECTED REGION ID(LiberaSinglePassE::Class::attribute_factory_before) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	LiberaSinglePassE::Class::attribute_factory_before


	//	Attribute : BufferSize
	BufferSizeAttrib	*buffersize = new BufferSizeAttrib();
	Tango::UserDefaultAttrProp	buffersize_prop;
	buffersize_prop.set_description("The Libera box ADC buffer size (between 10 and 8192)");
	buffersize_prop.set_label("Buffer Size");
	buffersize_prop.set_unit("samples");
	//	standard_unit	not set for	BufferSize
	//	display_unit	not set for	BufferSize
	buffersize_prop.set_format("%4d");
	buffersize_prop.set_max_value("8192");
	buffersize_prop.set_min_value("10");
	//	max_alarm	not set for	BufferSize
	//	min_alarm	not set for	BufferSize
	//	max_warning	not set for	BufferSize
	//	min_warning	not set for	BufferSize
	//	delta_t	not set for	BufferSize
	//	delta_val	not set for	BufferSize
	buffersize->set_default_properties(buffersize_prop);
	//	Not Polled
	buffersize->set_disp_level(Tango::OPERATOR);
	buffersize->set_memorized();
	buffersize->set_memorized_init(true);
	//	BufferSize does not fire change event
	//	BufferSize does not fire archive event
	//	BufferSize does not fire data_ready event
	att_list.push_back(buffersize);

	//	Attribute : AttenuationLevel
	AttenuationLevelAttrib	*attenuationlevel = new AttenuationLevelAttrib();
	Tango::UserDefaultAttrProp	attenuationlevel_prop;
	attenuationlevel_prop.set_description("Each analogue channel on one processor module in \nLibera Single Pass E has one 5-bit programmable \nattenuator. The attenuation can be controlled in the \nrange from 0 to 31dB in steps of 1dB. Gain control serves \nto set the attenuators according to the input RF signal \nlevel. Writing to this attribute serves to set the input \nRF signal attenuators in dB.");
	attenuationlevel_prop.set_label("AttenuationLevel");
	attenuationlevel_prop.set_unit("dBm");
	//	standard_unit	not set for	AttenuationLevel
	//	display_unit	not set for	AttenuationLevel
	attenuationlevel_prop.set_format("%2d");
	attenuationlevel_prop.set_max_value("31");
	attenuationlevel_prop.set_min_value("0");
	//	max_alarm	not set for	AttenuationLevel
	//	min_alarm	not set for	AttenuationLevel
	//	max_warning	not set for	AttenuationLevel
	//	min_warning	not set for	AttenuationLevel
	//	delta_t	not set for	AttenuationLevel
	//	delta_val	not set for	AttenuationLevel
	attenuationlevel->set_default_properties(attenuationlevel_prop);
	//	Not Polled
	attenuationlevel->set_disp_level(Tango::OPERATOR);
	//	Not memorized

	//	AttenuationLevel does not fire change event
	//	AttenuationLevel does not fire archive event
	//	AttenuationLevel does not fire data_ready event
	att_list.push_back(attenuationlevel);

	//	Attribute : TriggerCounter
	TriggerCounterAttrib	*triggercounter = new TriggerCounterAttrib();
	Tango::UserDefaultAttrProp	triggercounter_prop;
	triggercounter_prop.set_description("Trigger counter. Incremented at each trigger");
	triggercounter_prop.set_label("Trig. Counter");
	triggercounter_prop.set_unit(" ");
	triggercounter_prop.set_standard_unit(" ");
	//	display_unit	not set for	TriggerCounter
	triggercounter_prop.set_format("%d");
	//	max_value	not set for	TriggerCounter
	//	min_value	not set for	TriggerCounter
	//	max_alarm	not set for	TriggerCounter
	//	min_alarm	not set for	TriggerCounter
	//	max_warning	not set for	TriggerCounter
	//	min_warning	not set for	TriggerCounter
	//	delta_t	not set for	TriggerCounter
	//	delta_val	not set for	TriggerCounter
	triggercounter->set_default_properties(triggercounter_prop);
	//	Not Polled
	triggercounter->set_disp_level(Tango::OPERATOR);
	//	Not memorized

	//	TriggerCounter does not fire change event
	//	TriggerCounter does not fire archive event
	//	TriggerCounter does not fire data_ready event
	att_list.push_back(triggercounter);

	//	Attribute : Fan1Speed
	Fan1SpeedAttrib	*fan1speed = new Fan1SpeedAttrib();
	Tango::UserDefaultAttrProp	fan1speed_prop;
<<<<<<< HEAD
    fan1speed_prop.set_description("Provides minimal fan speed reading of all three fans on \nthe left side of the chassis in order to identify if the fan \nmodule (consisting of 3 fans) is broken - returned value \n0 means that at least one fan has stopped.");
=======
	fan1speed_prop.set_description("Provides minimal fan speed reading of all three� fans on \nthe left side of the chassis in order to identify if the fan \nmodule (consisting of 3 fans) is broken - returned value \n0 means that at least one fan has stopped.");
>>>>>>> c67445acda0196ffcd05861097d1d44451f8490f
	fan1speed_prop.set_label("Fan.1 speed");
	fan1speed_prop.set_unit("rpm");
	//	standard_unit	not set for	Fan1Speed
	//	display_unit	not set for	Fan1Speed
	fan1speed_prop.set_format("%4d");
	//	max_value	not set for	Fan1Speed
	//	min_value	not set for	Fan1Speed
	//	max_alarm	not set for	Fan1Speed
	//	min_alarm	not set for	Fan1Speed
	//	max_warning	not set for	Fan1Speed
	//	min_warning	not set for	Fan1Speed
	//	delta_t	not set for	Fan1Speed
	//	delta_val	not set for	Fan1Speed
	fan1speed->set_default_properties(fan1speed_prop);
	//	Not Polled
	fan1speed->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	Fan1Speed does not fire change event
	//	Fan1Speed does not fire archive event
	//	Fan1Speed does not fire data_ready event
	att_list.push_back(fan1speed);

	//	Attribute : Fan2Speed
	Fan2SpeedAttrib	*fan2speed = new Fan2SpeedAttrib();
	Tango::UserDefaultAttrProp	fan2speed_prop;
<<<<<<< HEAD
    fan2speed_prop.set_description("Provides minimal fan speed reading of all three fans on \nthe right side of the chassis in order to identify if the \nfan module (consisting of 3 fans) is broken - returned \nvalue 0 means that at least one fan has stopped.");
=======
	fan2speed_prop.set_description("Provides minimal fan speed reading of all three� fans on \nthe right side of the chassis in order to identify if the \nfan module (consisting of 3 fans) is broken - returned \nvalue 0 means that at least one fan has stopped.");
>>>>>>> c67445acda0196ffcd05861097d1d44451f8490f
	fan2speed_prop.set_label("Fan.2 speed");
	fan2speed_prop.set_unit("rpm");
	fan2speed_prop.set_standard_unit(" ");
	//	display_unit	not set for	Fan2Speed
	fan2speed_prop.set_format("%4d");
	//	max_value	not set for	Fan2Speed
	//	min_value	not set for	Fan2Speed
	//	max_alarm	not set for	Fan2Speed
	//	min_alarm	not set for	Fan2Speed
	//	max_warning	not set for	Fan2Speed
	//	min_warning	not set for	Fan2Speed
	//	delta_t	not set for	Fan2Speed
	//	delta_val	not set for	Fan2Speed
	fan2speed->set_default_properties(fan2speed_prop);
	//	Not Polled
	fan2speed->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	Fan2Speed does not fire change event
	//	Fan2Speed does not fire archive event
	//	Fan2Speed does not fire data_ready event
	att_list.push_back(fan2speed);

	//	Attribute : Temp1
	Temp1Attrib	*temp1 = new Temp1Attrib();
	Tango::UserDefaultAttrProp	temp1_prop;
	temp1_prop.set_description("Temperature of the hottest component on the BPM \nmodule is returned.");
	temp1_prop.set_label("Temperature 1");
	temp1_prop.set_unit("C deg");
	//	standard_unit	not set for	Temp1
	//	display_unit	not set for	Temp1
	temp1_prop.set_format("%2d");
	//	max_value	not set for	Temp1
	//	min_value	not set for	Temp1
	temp1_prop.set_max_alarm("65");
	//	min_alarm	not set for	Temp1
	//	max_warning	not set for	Temp1
	//	min_warning	not set for	Temp1
	//	delta_t	not set for	Temp1
	//	delta_val	not set for	Temp1
	temp1->set_default_properties(temp1_prop);
	//	Not Polled
	temp1->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	Temp1 does not fire change event
	//	Temp1 does not fire archive event
	//	Temp1 does not fire data_ready event
	att_list.push_back(temp1);

	//	Attribute : Temp2
	Temp2Attrib	*temp2 = new Temp2Attrib();
	Tango::UserDefaultAttrProp	temp2_prop;
	temp2_prop.set_description("Temperature of the hottest component on the chassis \ninterconnection board is returned.");
	temp2_prop.set_label("Temperature 2");
	temp2_prop.set_unit("C deg");
	//	standard_unit	not set for	Temp2
	//	display_unit	not set for	Temp2
	temp2_prop.set_format("%2d");
	//	max_value	not set for	Temp2
	//	min_value	not set for	Temp2
	temp2_prop.set_max_alarm("65");
	//	min_alarm	not set for	Temp2
	//	max_warning	not set for	Temp2
	//	min_warning	not set for	Temp2
	//	delta_t	not set for	Temp2
	//	delta_val	not set for	Temp2
	temp2->set_default_properties(temp2_prop);
	//	Not Polled
	temp2->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	Temp2 does not fire change event
	//	Temp2 does not fire archive event
	//	Temp2 does not fire data_ready event
	att_list.push_back(temp2);

	//	Attribute : Temp3
	Temp3Attrib	*temp3 = new Temp3Attrib();
	Tango::UserDefaultAttrProp	temp3_prop;
	temp3_prop.set_description("Temperature of the hottest component on the timing \nmodule is returned.");
	temp3_prop.set_label("Temperature 3");
	temp3_prop.set_unit("C deg");
	//	standard_unit	not set for	Temp3
	//	display_unit	not set for	Temp3
	temp3_prop.set_format("%2d");
	//	max_value	not set for	Temp3
	//	min_value	not set for	Temp3
	temp3_prop.set_max_alarm("65");
	//	min_alarm	not set for	Temp3
	//	max_warning	not set for	Temp3
	//	min_warning	not set for	Temp3
	//	delta_t	not set for	Temp3
	//	delta_val	not set for	Temp3
	temp3->set_default_properties(temp3_prop);
	//	Not Polled
	temp3->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	Temp3 does not fire change event
	//	Temp3 does not fire archive event
	//	Temp3 does not fire data_ready event
	att_list.push_back(temp3);

	//	Attribute : CalibrationKa
	CalibrationKaAttrib	*calibrationka = new CalibrationKaAttrib();
	Tango::UserDefaultAttrProp	calibrationka_prop;
	calibrationka_prop.set_description("Correction coefficient of the pickup sensor for channel A.");
	calibrationka_prop.set_label("calibrationKa");
	calibrationka_prop.set_unit("a.u.");
	//	standard_unit	not set for	CalibrationKa
	//	display_unit	not set for	CalibrationKa
	//	format	not set for	CalibrationKa
	//	max_value	not set for	CalibrationKa
	//	min_value	not set for	CalibrationKa
	//	max_alarm	not set for	CalibrationKa
	//	min_alarm	not set for	CalibrationKa
	//	max_warning	not set for	CalibrationKa
	//	min_warning	not set for	CalibrationKa
	//	delta_t	not set for	CalibrationKa
	//	delta_val	not set for	CalibrationKa
	calibrationka->set_default_properties(calibrationka_prop);
	//	Not Polled
	calibrationka->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	CalibrationKa does not fire change event
	//	CalibrationKa does not fire archive event
	//	CalibrationKa does not fire data_ready event
	att_list.push_back(calibrationka);

	//	Attribute : CalibrationKb
	CalibrationKbAttrib	*calibrationkb = new CalibrationKbAttrib();
	Tango::UserDefaultAttrProp	calibrationkb_prop;
	calibrationkb_prop.set_description("Correction coefficient of the pickup sensor for channel B.");
	calibrationkb_prop.set_label("calibrationKb");
	calibrationkb_prop.set_unit("a.u.");
	//	standard_unit	not set for	CalibrationKb
	//	display_unit	not set for	CalibrationKb
	//	format	not set for	CalibrationKb
	//	max_value	not set for	CalibrationKb
	//	min_value	not set for	CalibrationKb
	//	max_alarm	not set for	CalibrationKb
	//	min_alarm	not set for	CalibrationKb
	//	max_warning	not set for	CalibrationKb
	//	min_warning	not set for	CalibrationKb
	//	delta_t	not set for	CalibrationKb
	//	delta_val	not set for	CalibrationKb
	calibrationkb->set_default_properties(calibrationkb_prop);
	//	Not Polled
	calibrationkb->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	CalibrationKb does not fire change event
	//	CalibrationKb does not fire archive event
	//	CalibrationKb does not fire data_ready event
	att_list.push_back(calibrationkb);

	//	Attribute : CalibrationKc
	CalibrationKcAttrib	*calibrationkc = new CalibrationKcAttrib();
	Tango::UserDefaultAttrProp	calibrationkc_prop;
	calibrationkc_prop.set_description("Correction coefficient of the pickup sensor for channel C.");
	calibrationkc_prop.set_label("calibrationKc");
	calibrationkc_prop.set_unit("a.u.");
	//	standard_unit	not set for	CalibrationKc
	//	display_unit	not set for	CalibrationKc
	//	format	not set for	CalibrationKc
	//	max_value	not set for	CalibrationKc
	//	min_value	not set for	CalibrationKc
	//	max_alarm	not set for	CalibrationKc
	//	min_alarm	not set for	CalibrationKc
	//	max_warning	not set for	CalibrationKc
	//	min_warning	not set for	CalibrationKc
	//	delta_t	not set for	CalibrationKc
	//	delta_val	not set for	CalibrationKc
	calibrationkc->set_default_properties(calibrationkc_prop);
	//	Not Polled
	calibrationkc->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	CalibrationKc does not fire change event
	//	CalibrationKc does not fire archive event
	//	CalibrationKc does not fire data_ready event
	att_list.push_back(calibrationkc);

	//	Attribute : CalibrationKd
	CalibrationKdAttrib	*calibrationkd = new CalibrationKdAttrib();
	Tango::UserDefaultAttrProp	calibrationkd_prop;
	calibrationkd_prop.set_description("Correction coefficient of the pickup sensor for channel D.");
	calibrationkd_prop.set_label("calibrationKd");
	calibrationkd_prop.set_unit("a.u.");
	//	standard_unit	not set for	CalibrationKd
	//	display_unit	not set for	CalibrationKd
	//	format	not set for	CalibrationKd
	//	max_value	not set for	CalibrationKd
	//	min_value	not set for	CalibrationKd
	//	max_alarm	not set for	CalibrationKd
	//	min_alarm	not set for	CalibrationKd
	//	max_warning	not set for	CalibrationKd
	//	min_warning	not set for	CalibrationKd
	//	delta_t	not set for	CalibrationKd
	//	delta_val	not set for	CalibrationKd
	calibrationkd->set_default_properties(calibrationkd_prop);
	//	Not Polled
	calibrationkd->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	CalibrationKd does not fire change event
	//	CalibrationKd does not fire archive event
	//	CalibrationKd does not fire data_ready event
	att_list.push_back(calibrationkd);

	//	Attribute : LinearXK
	LinearXKAttrib	*linearxk = new LinearXKAttrib();
	Tango::UserDefaultAttrProp	linearxk_prop;
	linearxk_prop.set_description("Setting the correction coefficient of the linear equation \nfor the x position calculation. See chapter 2.6.1 in \nLibera Single Pass E User manual for details.");
	linearxk_prop.set_label("LinearXK");
	linearxk_prop.set_unit("nm");
	//	standard_unit	not set for	LinearXK
	//	display_unit	not set for	LinearXK
	//	format	not set for	LinearXK
	//	max_value	not set for	LinearXK
	//	min_value	not set for	LinearXK
	//	max_alarm	not set for	LinearXK
	//	min_alarm	not set for	LinearXK
	//	max_warning	not set for	LinearXK
	//	min_warning	not set for	LinearXK
	//	delta_t	not set for	LinearXK
	//	delta_val	not set for	LinearXK
	linearxk->set_default_properties(linearxk_prop);
	//	Not Polled
	linearxk->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	LinearXK does not fire change event
	//	LinearXK does not fire archive event
	//	LinearXK does not fire data_ready event
	att_list.push_back(linearxk);

	//	Attribute : LinearXOffs
	LinearXOffsAttrib	*linearxoffs = new LinearXOffsAttrib();
	Tango::UserDefaultAttrProp	linearxoffs_prop;
	linearxoffs_prop.set_description("Used to calibrate position offsets expressed in nm. \nPlease refer to Chapter 2.6 in Libera Single Pass E \nUser manual for details.");
	linearxoffs_prop.set_label("LinearXOffs");
	linearxoffs_prop.set_unit("nm");
	//	standard_unit	not set for	LinearXOffs
	//	display_unit	not set for	LinearXOffs
	//	format	not set for	LinearXOffs
	//	max_value	not set for	LinearXOffs
	//	min_value	not set for	LinearXOffs
	//	max_alarm	not set for	LinearXOffs
	//	min_alarm	not set for	LinearXOffs
	//	max_warning	not set for	LinearXOffs
	//	min_warning	not set for	LinearXOffs
	//	delta_t	not set for	LinearXOffs
	//	delta_val	not set for	LinearXOffs
	linearxoffs->set_default_properties(linearxoffs_prop);
	//	Not Polled
	linearxoffs->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	LinearXOffs does not fire change event
	//	LinearXOffs does not fire archive event
	//	LinearXOffs does not fire data_ready event
	att_list.push_back(linearxoffs);

	//	Attribute : LinearYK
	LinearYKAttrib	*linearyk = new LinearYKAttrib();
	Tango::UserDefaultAttrProp	linearyk_prop;
	linearyk_prop.set_description("Setting the correction coefficient of the linear equation \nfor the y position calculation. See chapter 2.6.1 in \nLibera Single Pass E User manual for details.");
	linearyk_prop.set_label("LinearYK");
	linearyk_prop.set_unit("nm");
	//	standard_unit	not set for	LinearYK
	//	display_unit	not set for	LinearYK
	//	format	not set for	LinearYK
	//	max_value	not set for	LinearYK
	//	min_value	not set for	LinearYK
	//	max_alarm	not set for	LinearYK
	//	min_alarm	not set for	LinearYK
	//	max_warning	not set for	LinearYK
	//	min_warning	not set for	LinearYK
	//	delta_t	not set for	LinearYK
	//	delta_val	not set for	LinearYK
	linearyk->set_default_properties(linearyk_prop);
	//	Not Polled
	linearyk->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	LinearYK does not fire change event
	//	LinearYK does not fire archive event
	//	LinearYK does not fire data_ready event
	att_list.push_back(linearyk);

	//	Attribute : LinearYOffs
	LinearYOffsAttrib	*linearyoffs = new LinearYOffsAttrib();
	Tango::UserDefaultAttrProp	linearyoffs_prop;
	linearyoffs_prop.set_description("Used to calibrate position offsets expressed in nm. \nPlease refer to Chapter 2.6 in Libera Single Pass E \nUser manual for details.");
	linearyoffs_prop.set_label("LinearYOffs");
	linearyoffs_prop.set_unit("nm");
	//	standard_unit	not set for	LinearYOffs
	//	display_unit	not set for	LinearYOffs
	//	format	not set for	LinearYOffs
	//	max_value	not set for	LinearYOffs
	//	min_value	not set for	LinearYOffs
	//	max_alarm	not set for	LinearYOffs
	//	min_alarm	not set for	LinearYOffs
	//	max_warning	not set for	LinearYOffs
	//	min_warning	not set for	LinearYOffs
	//	delta_t	not set for	LinearYOffs
	//	delta_val	not set for	LinearYOffs
	linearyoffs->set_default_properties(linearyoffs_prop);
	//	Not Polled
	linearyoffs->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	LinearYOffs does not fire change event
	//	LinearYOffs does not fire archive event
	//	LinearYOffs does not fire data_ready event
	att_list.push_back(linearyoffs);

	//	Attribute : LinearQK
	LinearQKAttrib	*linearqk = new LinearQKAttrib();
	Tango::UserDefaultAttrProp	linearqk_prop;
	linearqk_prop.set_description("Setting the correction coefficient of the linear equation \nfor the q calculation. See chapter 2.6.1 in Libera Single \nPass E User manual for details.");
	linearqk_prop.set_label("LinearQK");
	linearqk_prop.set_unit("a.u.");
	//	standard_unit	not set for	LinearQK
	//	display_unit	not set for	LinearQK
	//	format	not set for	LinearQK
	//	max_value	not set for	LinearQK
	//	min_value	not set for	LinearQK
	//	max_alarm	not set for	LinearQK
	//	min_alarm	not set for	LinearQK
	//	max_warning	not set for	LinearQK
	//	min_warning	not set for	LinearQK
	//	delta_t	not set for	LinearQK
	//	delta_val	not set for	LinearQK
	linearqk->set_default_properties(linearqk_prop);
	//	Not Polled
	linearqk->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	LinearQK does not fire change event
	//	LinearQK does not fire archive event
	//	LinearQK does not fire data_ready event
	att_list.push_back(linearqk);

	//	Attribute : LinearQOffs
	LinearQOffsAttrib	*linearqoffs = new LinearQOffsAttrib();
	Tango::UserDefaultAttrProp	linearqoffs_prop;
	linearqoffs_prop.set_description("Sets the offset for q factor. Default value is 0. \nSee Chapter 2.6 in Libera Single Pass E User manual \nfor details.");
	linearqoffs_prop.set_label("LinearQOffs");
	linearqoffs_prop.set_unit("a.u.");
	//	standard_unit	not set for	LinearQOffs
	//	display_unit	not set for	LinearQOffs
	//	format	not set for	LinearQOffs
	//	max_value	not set for	LinearQOffs
	//	min_value	not set for	LinearQOffs
	//	max_alarm	not set for	LinearQOffs
	//	min_alarm	not set for	LinearQOffs
	//	max_warning	not set for	LinearQOffs
	//	min_warning	not set for	LinearQOffs
	//	delta_t	not set for	LinearQOffs
	//	delta_val	not set for	LinearQOffs
	linearqoffs->set_default_properties(linearqoffs_prop);
	//	Not Polled
	linearqoffs->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	LinearQOffs does not fire change event
	//	LinearQOffs does not fire archive event
	//	LinearQOffs does not fire data_ready event
	att_list.push_back(linearqoffs);

	//	Attribute : LinearSumK
	LinearSumKAttrib	*linearsumk = new LinearSumKAttrib();
	Tango::UserDefaultAttrProp	linearsumk_prop;
	linearsumk_prop.set_description("Coefficient for sum value. Default is 67108864 (2^26). \nPlease refer to Chapter 2.6 in the Libera Single Pass E \nUser manual for details.");
	linearsumk_prop.set_label("LinearSumK");
	linearsumk_prop.set_unit("a.u.");
	//	standard_unit	not set for	LinearSumK
	//	display_unit	not set for	LinearSumK
	//	format	not set for	LinearSumK
	//	max_value	not set for	LinearSumK
	//	min_value	not set for	LinearSumK
	//	max_alarm	not set for	LinearSumK
	//	min_alarm	not set for	LinearSumK
	//	max_warning	not set for	LinearSumK
	//	min_warning	not set for	LinearSumK
	//	delta_t	not set for	LinearSumK
	//	delta_val	not set for	LinearSumK
	linearsumk->set_default_properties(linearsumk_prop);
	//	Not Polled
	linearsumk->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	LinearSumK does not fire change event
	//	LinearSumK does not fire archive event
	//	LinearSumK does not fire data_ready event
	att_list.push_back(linearsumk);

	//	Attribute : LinearSumOffs
	LinearSumOffsAttrib	*linearsumoffs = new LinearSumOffsAttrib();
	Tango::UserDefaultAttrProp	linearsumoffs_prop;
	linearsumoffs_prop.set_description("Coefficient for offsetting the sum value. \nDefault value is 0. Please refer to Chapter 2.6 of Libera \nSingle Pass E User manual for details.\n\nNOTE: The Libera Single Pass E has the possibility to \nsupport also the polynomial equations for calculation \nof position, however it is not supported in Tango as the \nLibera Brilliance Single Pass supports only the linear \nequation. Polynomial equation is providing more \naccurate results of measurements as it is \ncompensating for the nonlinear anomalies for the \npick-up sensor. Please see the chapter 2.6.2 in the \nLibera Single Pass E user manual for details.");
	linearsumoffs_prop.set_label("LinearSumOffs");
	linearsumoffs_prop.set_unit("a.u.");
	//	standard_unit	not set for	LinearSumOffs
	//	display_unit	not set for	LinearSumOffs
	//	format	not set for	LinearSumOffs
	//	max_value	not set for	LinearSumOffs
	//	min_value	not set for	LinearSumOffs
	//	max_alarm	not set for	LinearSumOffs
	//	min_alarm	not set for	LinearSumOffs
	//	max_warning	not set for	LinearSumOffs
	//	min_warning	not set for	LinearSumOffs
	//	delta_t	not set for	LinearSumOffs
	//	delta_val	not set for	LinearSumOffs
	linearsumoffs->set_default_properties(linearsumoffs_prop);
	//	Not Polled
	linearsumoffs->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	LinearSumOffs does not fire change event
	//	LinearSumOffs does not fire archive event
	//	LinearSumOffs does not fire data_ready event
	att_list.push_back(linearsumoffs);

	//	Attribute : SignalExpansion
	SignalExpansionAttrib	*signalexpansion = new SignalExpansionAttrib();
	Tango::UserDefaultAttrProp	signalexpansion_prop;
	signalexpansion_prop.set_description("Interlock output is active for all the time the Interlock \nconditions are fulfilled (ADC overflow and position \nmonitoring). The Interlock output remains active for a \ncertain time after the conditions have been cleared \n(mono-stable cell). The time is defined in ADC clock \ncycles with ireg parameter signal_expansion.");
	signalexpansion_prop.set_label("SignalExpansion");
	//	unit	not set for	SignalExpansion
	//	standard_unit	not set for	SignalExpansion
	//	display_unit	not set for	SignalExpansion
	//	format	not set for	SignalExpansion
	//	max_value	not set for	SignalExpansion
	//	min_value	not set for	SignalExpansion
	//	max_alarm	not set for	SignalExpansion
	//	min_alarm	not set for	SignalExpansion
	//	max_warning	not set for	SignalExpansion
	//	min_warning	not set for	SignalExpansion
	//	delta_t	not set for	SignalExpansion
	//	delta_val	not set for	SignalExpansion
	signalexpansion->set_default_properties(signalexpansion_prop);
	//	Not Polled
	signalexpansion->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	SignalExpansion does not fire change event
	//	SignalExpansion does not fire archive event
	//	SignalExpansion does not fire data_ready event
	att_list.push_back(signalexpansion);

	//	Attribute : InterlockEnabled
	InterlockEnabledAttrib	*interlockenabled = new InterlockEnabledAttrib();
	Tango::UserDefaultAttrProp	interlockenabled_prop;
	interlockenabled_prop.set_description("Enables/disables the interlock functionality. If it is set to \ntrue, interlock is enabled, if set to false, interlock is \ndisabled. More details are in the chapter 2.12 in the \nLibera Single Pass E User manual.");
	interlockenabled_prop.set_label("InterlockEnabled");
	//	unit	not set for	InterlockEnabled
	//	standard_unit	not set for	InterlockEnabled
	//	display_unit	not set for	InterlockEnabled
	//	format	not set for	InterlockEnabled
	//	max_value	not set for	InterlockEnabled
	//	min_value	not set for	InterlockEnabled
	//	max_alarm	not set for	InterlockEnabled
	//	min_alarm	not set for	InterlockEnabled
	//	max_warning	not set for	InterlockEnabled
	//	min_warning	not set for	InterlockEnabled
	//	delta_t	not set for	InterlockEnabled
	//	delta_val	not set for	InterlockEnabled
	interlockenabled->set_default_properties(interlockenabled_prop);
	//	Not Polled
	interlockenabled->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	InterlockEnabled does not fire change event
	//	InterlockEnabled does not fire archive event
	//	InterlockEnabled does not fire data_ready event
	att_list.push_back(interlockenabled);

	//	Attribute : LimitMinX
	LimitMinXAttrib	*limitminx = new LimitMinXAttrib();
	Tango::UserDefaultAttrProp	limitminx_prop;
	limitminx_prop.set_description("Interlock lower limit parameter for x position in nm. \nSee Chapter 2.12.1 in the Libera Single Pass E User \nmanual for details.");
	limitminx_prop.set_label("LimitMinX");
	limitminx_prop.set_unit("nm");
	//	standard_unit	not set for	LimitMinX
	//	display_unit	not set for	LimitMinX
	//	format	not set for	LimitMinX
	//	max_value	not set for	LimitMinX
	//	min_value	not set for	LimitMinX
	//	max_alarm	not set for	LimitMinX
	//	min_alarm	not set for	LimitMinX
	//	max_warning	not set for	LimitMinX
	//	min_warning	not set for	LimitMinX
	//	delta_t	not set for	LimitMinX
	//	delta_val	not set for	LimitMinX
	limitminx->set_default_properties(limitminx_prop);
	//	Not Polled
	limitminx->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	LimitMinX does not fire change event
	//	LimitMinX does not fire archive event
	//	LimitMinX does not fire data_ready event
	att_list.push_back(limitminx);

	//	Attribute : LimitMinY
	LimitMinYAttrib	*limitminy = new LimitMinYAttrib();
	Tango::UserDefaultAttrProp	limitminy_prop;
	limitminy_prop.set_description("Interlock lower limit parameter for y position in nm. \nSee Chapter 2.12.1 in the Libera Single Pass E User \nmanual for details.");
	limitminy_prop.set_label("LimitMinY");
	limitminy_prop.set_unit("nm");
	//	standard_unit	not set for	LimitMinY
	//	display_unit	not set for	LimitMinY
	//	format	not set for	LimitMinY
	//	max_value	not set for	LimitMinY
	//	min_value	not set for	LimitMinY
	//	max_alarm	not set for	LimitMinY
	//	min_alarm	not set for	LimitMinY
	//	max_warning	not set for	LimitMinY
	//	min_warning	not set for	LimitMinY
	//	delta_t	not set for	LimitMinY
	//	delta_val	not set for	LimitMinY
	limitminy->set_default_properties(limitminy_prop);
	//	Not Polled
	limitminy->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	LimitMinY does not fire change event
	//	LimitMinY does not fire archive event
	//	LimitMinY does not fire data_ready event
	att_list.push_back(limitminy);

	//	Attribute : LimitMaxX
	LimitMaxXAttrib	*limitmaxx = new LimitMaxXAttrib();
	Tango::UserDefaultAttrProp	limitmaxx_prop;
	limitmaxx_prop.set_description("Interlock upper limit parameter for x position in nm. \nSee Chapter 2.12.1 in the Libera Single Pass E User \nmanual for details.");
	limitmaxx_prop.set_label("LimitMaxX");
	limitmaxx_prop.set_unit("nm");
	//	standard_unit	not set for	LimitMaxX
	//	display_unit	not set for	LimitMaxX
	//	format	not set for	LimitMaxX
	//	max_value	not set for	LimitMaxX
	//	min_value	not set for	LimitMaxX
	//	max_alarm	not set for	LimitMaxX
	//	min_alarm	not set for	LimitMaxX
	//	max_warning	not set for	LimitMaxX
	//	min_warning	not set for	LimitMaxX
	//	delta_t	not set for	LimitMaxX
	//	delta_val	not set for	LimitMaxX
	limitmaxx->set_default_properties(limitmaxx_prop);
	//	Not Polled
	limitmaxx->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	LimitMaxX does not fire change event
	//	LimitMaxX does not fire archive event
	//	LimitMaxX does not fire data_ready event
	att_list.push_back(limitmaxx);

	//	Attribute : LimitMaxY
	LimitMaxYAttrib	*limitmaxy = new LimitMaxYAttrib();
	Tango::UserDefaultAttrProp	limitmaxy_prop;
	limitmaxy_prop.set_description("Interlock upper limit parameter for y position in nm. \nSee Chapter 2.12.1 in the Libera Single Pass E User \nmanual for details.");
	limitmaxy_prop.set_label("LimitMaxY");
	limitmaxy_prop.set_unit("nm");
	//	standard_unit	not set for	LimitMaxY
	//	display_unit	not set for	LimitMaxY
	//	format	not set for	LimitMaxY
	//	max_value	not set for	LimitMaxY
	//	min_value	not set for	LimitMaxY
	//	max_alarm	not set for	LimitMaxY
	//	min_alarm	not set for	LimitMaxY
	//	max_warning	not set for	LimitMaxY
	//	min_warning	not set for	LimitMaxY
	//	delta_t	not set for	LimitMaxY
	//	delta_val	not set for	LimitMaxY
	limitmaxy->set_default_properties(limitmaxy_prop);
	//	Not Polled
	limitmaxy->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	LimitMaxY does not fire change event
	//	LimitMaxY does not fire archive event
	//	LimitMaxY does not fire data_ready event
	att_list.push_back(limitmaxy);

	//	Attribute : OverflowThreshold
	OverflowThresholdAttrib	*overflowthreshold = new OverflowThresholdAttrib();
	Tango::UserDefaultAttrProp	overflowthreshold_prop;
	overflowthreshold_prop.set_description("Interlock upper limit parameter for the ADC overflow \nbuffer (ADC saturation) parameter which is in ADC \ncounts. See Chapter 2.12.2 in the Libera Single Pass E \nUser manual for details.");
	overflowthreshold_prop.set_label("OverflowThreshold");
	overflowthreshold_prop.set_unit("ADC counts");
	//	standard_unit	not set for	OverflowThreshold
	//	display_unit	not set for	OverflowThreshold
	//	format	not set for	OverflowThreshold
	//	max_value	not set for	OverflowThreshold
	//	min_value	not set for	OverflowThreshold
	//	max_alarm	not set for	OverflowThreshold
	//	min_alarm	not set for	OverflowThreshold
	//	max_warning	not set for	OverflowThreshold
	//	min_warning	not set for	OverflowThreshold
	//	delta_t	not set for	OverflowThreshold
	//	delta_val	not set for	OverflowThreshold
	overflowthreshold->set_default_properties(overflowthreshold_prop);
	//	Not Polled
	overflowthreshold->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	OverflowThreshold does not fire change event
	//	OverflowThreshold does not fire archive event
	//	OverflowThreshold does not fire data_ready event
	att_list.push_back(overflowthreshold);

	//	Attribute : InterlockStatus
	InterlockStatusAttrib	*interlockstatus = new InterlockStatusAttrib();
	Tango::UserDefaultAttrProp	interlockstatus_prop;
	interlockstatus_prop.set_description("Issuing this command tells you which was the cause of \nthe interlock. Number is 5 bit expressed in the decimal \nvalue. If no interlock was triggered, the returned value \nis 0. See the chapter 2.12.3 in the Libera Single Pass E \nUser manual for details.");
	interlockstatus_prop.set_label("InterlockStatus");
	//	unit	not set for	InterlockStatus
	//	standard_unit	not set for	InterlockStatus
	//	display_unit	not set for	InterlockStatus
	//	format	not set for	InterlockStatus
	//	max_value	not set for	InterlockStatus
	//	min_value	not set for	InterlockStatus
	//	max_alarm	not set for	InterlockStatus
	//	min_alarm	not set for	InterlockStatus
	//	max_warning	not set for	InterlockStatus
	//	min_warning	not set for	InterlockStatus
	//	delta_t	not set for	InterlockStatus
	//	delta_val	not set for	InterlockStatus
	interlockstatus->set_default_properties(interlockstatus_prop);
	//	Not Polled
	interlockstatus->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	InterlockStatus does not fire change event
	//	InterlockStatus does not fire archive event
	//	InterlockStatus does not fire data_ready event
	att_list.push_back(interlockstatus);

	//	Attribute : StatusX
	StatusXAttrib	*statusx = new StatusXAttrib();
	Tango::UserDefaultAttrProp	statusx_prop;
	statusx_prop.set_description("Checking the status of the interlock for the x position. \nReturned value 'false' means that x position wasn't out \nof set limit.");
	statusx_prop.set_label("StatusX");
	//	unit	not set for	StatusX
	//	standard_unit	not set for	StatusX
	//	display_unit	not set for	StatusX
	//	format	not set for	StatusX
	//	max_value	not set for	StatusX
	//	min_value	not set for	StatusX
	//	max_alarm	not set for	StatusX
	//	min_alarm	not set for	StatusX
	//	max_warning	not set for	StatusX
	//	min_warning	not set for	StatusX
	//	delta_t	not set for	StatusX
	//	delta_val	not set for	StatusX
	statusx->set_default_properties(statusx_prop);
	//	Not Polled
	statusx->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	StatusX does not fire change event
	//	StatusX does not fire archive event
	//	StatusX does not fire data_ready event
	att_list.push_back(statusx);

	//	Attribute : StatusY
	StatusYAttrib	*statusy = new StatusYAttrib();
	Tango::UserDefaultAttrProp	statusy_prop;
	statusy_prop.set_description("Checking the status of the interlock for the y position. \nReturned value 'false' means that y position wasn't out \nof set limit.");
	statusy_prop.set_label("StatusY");
	//	unit	not set for	StatusY
	//	standard_unit	not set for	StatusY
	//	display_unit	not set for	StatusY
	//	format	not set for	StatusY
	//	max_value	not set for	StatusY
	//	min_value	not set for	StatusY
	//	max_alarm	not set for	StatusY
	//	min_alarm	not set for	StatusY
	//	max_warning	not set for	StatusY
	//	min_warning	not set for	StatusY
	//	delta_t	not set for	StatusY
	//	delta_val	not set for	StatusY
	statusy->set_default_properties(statusy_prop);
	//	Not Polled
	statusy->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	StatusY does not fire change event
	//	StatusY does not fire archive event
	//	StatusY does not fire data_ready event
	att_list.push_back(statusy);

	//	Attribute : StatusAdcOverflow
	StatusAdcOverflowAttrib	*statusadcoverflow = new StatusAdcOverflowAttrib();
	Tango::UserDefaultAttrProp	statusadcoverflow_prop;
	statusadcoverflow_prop.set_description("Checking the status of the interlock for the ADC \nsaturation. Returned value 'false' means that ADC \nwasn't in saturation.");
	statusadcoverflow_prop.set_label("StatusAdcOverflow");
	//	unit	not set for	StatusAdcOverflow
	//	standard_unit	not set for	StatusAdcOverflow
	//	display_unit	not set for	StatusAdcOverflow
	//	format	not set for	StatusAdcOverflow
	//	max_value	not set for	StatusAdcOverflow
	//	min_value	not set for	StatusAdcOverflow
	//	max_alarm	not set for	StatusAdcOverflow
	//	min_alarm	not set for	StatusAdcOverflow
	//	max_warning	not set for	StatusAdcOverflow
	//	min_warning	not set for	StatusAdcOverflow
	//	delta_t	not set for	StatusAdcOverflow
	//	delta_val	not set for	StatusAdcOverflow
	statusadcoverflow->set_default_properties(statusadcoverflow_prop);
	//	Not Polled
	statusadcoverflow->set_disp_level(Tango::EXPERT);
	//	Not memorized

	//	StatusAdcOverflow does not fire change event
	//	StatusAdcOverflow does not fire archive event
	//	StatusAdcOverflow does not fire data_ready event
	att_list.push_back(statusadcoverflow);

	//	Attribute : A
	AAttrib	*a = new AAttrib();
	Tango::UserDefaultAttrProp	a_prop;
	a_prop.set_description("The A StripLine ADC buffer");
	a_prop.set_label("A ADC buffer");
	a_prop.set_unit("a.u");
	//	standard_unit	not set for	A
	//	display_unit	not set for	A
	a_prop.set_format("%6d");
	//	max_value	not set for	A
	//	min_value	not set for	A
	//	max_alarm	not set for	A
	//	min_alarm	not set for	A
	//	max_warning	not set for	A
	//	min_warning	not set for	A
	//	delta_t	not set for	A
	//	delta_val	not set for	A
	a->set_default_properties(a_prop);
	//	Not Polled
	a->set_disp_level(Tango::OPERATOR);
	//	Not memorized

	//	A does not fire change event
	//	A does not fire archive event
	//	A does not fire data_ready event
	att_list.push_back(a);

	//	Attribute : B
	BAttrib	*b = new BAttrib();
	Tango::UserDefaultAttrProp	b_prop;
	b_prop.set_description("The B StripLine ADC buffer");
	b_prop.set_label("B ADC buffer");
	b_prop.set_unit("a.u");
	//	standard_unit	not set for	B
	//	display_unit	not set for	B
	b_prop.set_format("%6d");
	//	max_value	not set for	B
	//	min_value	not set for	B
	//	max_alarm	not set for	B
	//	min_alarm	not set for	B
	//	max_warning	not set for	B
	//	min_warning	not set for	B
	//	delta_t	not set for	B
	//	delta_val	not set for	B
	b->set_default_properties(b_prop);
	//	Not Polled
	b->set_disp_level(Tango::OPERATOR);
	//	Not memorized

	//	B does not fire change event
	//	B does not fire archive event
	//	B does not fire data_ready event
	att_list.push_back(b);

	//	Attribute : C
	CAttrib	*c = new CAttrib();
	Tango::UserDefaultAttrProp	c_prop;
	c_prop.set_description("The C StripLine ADC buffer");
	c_prop.set_label("C ADC buffer");
	c_prop.set_unit("a.u");
	//	standard_unit	not set for	C
	//	display_unit	not set for	C
	c_prop.set_format("%6d");
	//	max_value	not set for	C
	//	min_value	not set for	C
	//	max_alarm	not set for	C
	//	min_alarm	not set for	C
	//	max_warning	not set for	C
	//	min_warning	not set for	C
	//	delta_t	not set for	C
	//	delta_val	not set for	C
	c->set_default_properties(c_prop);
	//	Not Polled
	c->set_disp_level(Tango::OPERATOR);
	//	Not memorized

	//	C does not fire change event
	//	C does not fire archive event
	//	C does not fire data_ready event
	att_list.push_back(c);

	//	Attribute : D
	DAttrib	*d = new DAttrib();
	Tango::UserDefaultAttrProp	d_prop;
	d_prop.set_description("The D StripLine ADC buffer");
	d_prop.set_label("D ADC buffer");
	d_prop.set_unit("a.u");
	//	standard_unit	not set for	D
	//	display_unit	not set for	D
	d_prop.set_format("%6d");
	//	max_value	not set for	D
	//	min_value	not set for	D
	//	max_alarm	not set for	D
	//	min_alarm	not set for	D
	//	max_warning	not set for	D
	//	min_warning	not set for	D
	//	delta_t	not set for	D
	//	delta_val	not set for	D
	d->set_default_properties(d_prop);
	//	Not Polled
	d->set_disp_level(Tango::OPERATOR);
	//	Not memorized

	//	D does not fire change event
	//	D does not fire archive event
	//	D does not fire data_ready event
	att_list.push_back(d);

	//	Attribute : AT
	ATAttrib	*at = new ATAttrib();
	Tango::UserDefaultAttrProp	at_prop;
	at_prop.set_description("The A StripLine ADC buffer after some computation:\nsquare - double averaging filter - square root");
	at_prop.set_label("Computed A ADC buffer");
	at_prop.set_unit("a.u");
	//	standard_unit	not set for	AT
	//	display_unit	not set for	AT
	at_prop.set_format("%8.2f");
	//	max_value	not set for	AT
	//	min_value	not set for	AT
	//	max_alarm	not set for	AT
	//	min_alarm	not set for	AT
	//	max_warning	not set for	AT
	//	min_warning	not set for	AT
	//	delta_t	not set for	AT
	//	delta_val	not set for	AT
	at->set_default_properties(at_prop);
	//	Not Polled
	at->set_disp_level(Tango::OPERATOR);
	//	Not memorized

	//	AT does not fire change event
	//	AT does not fire archive event
	//	AT does not fire data_ready event
	att_list.push_back(at);

	//	Attribute : BT
	BTAttrib	*bt = new BTAttrib();
	Tango::UserDefaultAttrProp	bt_prop;
	bt_prop.set_description("The B StripLine ADC buffer after some computation:\nsquare - double averaging filter - square root");
	bt_prop.set_label("Computed B ADC buffer");
	bt_prop.set_unit("a.u");
	//	standard_unit	not set for	BT
	//	display_unit	not set for	BT
	bt_prop.set_format("%8.2f");
	//	max_value	not set for	BT
	//	min_value	not set for	BT
	//	max_alarm	not set for	BT
	//	min_alarm	not set for	BT
	//	max_warning	not set for	BT
	//	min_warning	not set for	BT
	//	delta_t	not set for	BT
	//	delta_val	not set for	BT
	bt->set_default_properties(bt_prop);
	//	Not Polled
	bt->set_disp_level(Tango::OPERATOR);
	//	Not memorized

	//	BT does not fire change event
	//	BT does not fire archive event
	//	BT does not fire data_ready event
	att_list.push_back(bt);

	//	Attribute : CT
	CTAttrib	*ct = new CTAttrib();
	Tango::UserDefaultAttrProp	ct_prop;
	ct_prop.set_description("The C StripLine ADC buffer after some computation:\nsquare - double averaging filter - square root");
	ct_prop.set_label("Computed C ADC buffer");
	ct_prop.set_unit("a.u");
	//	standard_unit	not set for	CT
	//	display_unit	not set for	CT
	ct_prop.set_format("%8.2f");
	//	max_value	not set for	CT
	//	min_value	not set for	CT
	//	max_alarm	not set for	CT
	//	min_alarm	not set for	CT
	//	max_warning	not set for	CT
	//	min_warning	not set for	CT
	//	delta_t	not set for	CT
	//	delta_val	not set for	CT
	ct->set_default_properties(ct_prop);
	//	Not Polled
	ct->set_disp_level(Tango::OPERATOR);
	//	Not memorized

	//	CT does not fire change event
	//	CT does not fire archive event
	//	CT does not fire data_ready event
	att_list.push_back(ct);

	//	Attribute : DT
	DTAttrib	*dt = new DTAttrib();
	Tango::UserDefaultAttrProp	dt_prop;
	dt_prop.set_description("The D StripLine ADC buffer after some computation:\nsquare - double averaging filter - square root");
	dt_prop.set_label("Computed D ADC buffer");
	dt_prop.set_unit("a.u");
	//	standard_unit	not set for	DT
	//	display_unit	not set for	DT
	dt_prop.set_format("%8.2f");
	//	max_value	not set for	DT
	//	min_value	not set for	DT
	//	max_alarm	not set for	DT
	//	min_alarm	not set for	DT
	//	max_warning	not set for	DT
	//	min_warning	not set for	DT
	//	delta_t	not set for	DT
	//	delta_val	not set for	DT
	dt->set_default_properties(dt_prop);
	//	Not Polled
	dt->set_disp_level(Tango::OPERATOR);
	//	Not memorized

	//	DT does not fire change event
	//	DT does not fire archive event
	//	DT does not fire data_ready event
	att_list.push_back(dt);

	//	Attribute : Yposition
	YpositionAttrib	*yposition = new YpositionAttrib();
	Tango::UserDefaultAttrProp	yposition_prop;
	yposition_prop.set_description("Beam Y position (vertical)");
	yposition_prop.set_label("Beam Y position");
	yposition_prop.set_unit("mm");
	yposition_prop.set_standard_unit("0.001");
	//	display_unit	not set for	Yposition
	yposition_prop.set_format("%6.2f");
	//	max_value	not set for	Yposition
	//	min_value	not set for	Yposition
	//	max_alarm	not set for	Yposition
	//	min_alarm	not set for	Yposition
	//	max_warning	not set for	Yposition
	//	min_warning	not set for	Yposition
	//	delta_t	not set for	Yposition
	//	delta_val	not set for	Yposition
	yposition->set_default_properties(yposition_prop);
	//	Not Polled
	yposition->set_disp_level(Tango::OPERATOR);
	//	Not memorized

	//	Yposition does not fire change event
	//	Yposition does not fire archive event
	//	Yposition does not fire data_ready event
	att_list.push_back(yposition);

	//	Attribute : Xposition
	XpositionAttrib	*xposition = new XpositionAttrib();
	Tango::UserDefaultAttrProp	xposition_prop;
	xposition_prop.set_description("Beam X position (horizontal)");
	xposition_prop.set_label("Beam X position");
	xposition_prop.set_unit("mm");
	xposition_prop.set_standard_unit("0.001");
	//	display_unit	not set for	Xposition
	xposition_prop.set_format("%6.2f");
	//	max_value	not set for	Xposition
	//	min_value	not set for	Xposition
	//	max_alarm	not set for	Xposition
	//	min_alarm	not set for	Xposition
	//	max_warning	not set for	Xposition
	//	min_warning	not set for	Xposition
	//	delta_t	not set for	Xposition
	//	delta_val	not set for	Xposition
	xposition->set_default_properties(xposition_prop);
	//	Not Polled
	xposition->set_disp_level(Tango::OPERATOR);
	//	Not memorized

	//	Xposition does not fire change event
	//	Xposition does not fire archive event
	//	Xposition does not fire data_ready event
	att_list.push_back(xposition);

	//	Attribute : Current
	CurrentAttrib	*current = new CurrentAttrib();
	Tango::UserDefaultAttrProp	current_prop;
	current_prop.set_description("Beam current computed from strip lines data");
	current_prop.set_label("Computed beam current");
	current_prop.set_unit("mA");
	current_prop.set_standard_unit("0.001");
	//	display_unit	not set for	Current
	current_prop.set_format("%6.2f");
	//	max_value	not set for	Current
	//	min_value	not set for	Current
	//	max_alarm	not set for	Current
	//	min_alarm	not set for	Current
	//	max_warning	not set for	Current
	//	min_warning	not set for	Current
	//	delta_t	not set for	Current
	//	delta_val	not set for	Current
	current->set_default_properties(current_prop);
	//	Not Polled
	current->set_disp_level(Tango::OPERATOR);
	//	Not memorized

	//	Current does not fire change event
	//	Current does not fire archive event
	//	Current does not fire data_ready event
	att_list.push_back(current);

	//	Attribute : SumT
	SumTAttrib	*sumt = new SumTAttrib();
	Tango::UserDefaultAttrProp	sumt_prop;
	sumt_prop.set_description("Sum of the 4 computed ADC outputs (the xxxT attributes)");
	sumt_prop.set_label("SumT");
	sumt_prop.set_unit("a.u");
	//	standard_unit	not set for	SumT
	//	display_unit	not set for	SumT
	sumt_prop.set_format("%8.2f");
	//	max_value	not set for	SumT
	//	min_value	not set for	SumT
	//	max_alarm	not set for	SumT
	//	min_alarm	not set for	SumT
	//	max_warning	not set for	SumT
	//	min_warning	not set for	SumT
	//	delta_t	not set for	SumT
	//	delta_val	not set for	SumT
	sumt->set_default_properties(sumt_prop);
	//	Not Polled
	sumt->set_disp_level(Tango::OPERATOR);
	//	Not memorized

	//	SumT does not fire change event
	//	SumT does not fire archive event
	//	SumT does not fire data_ready event
	att_list.push_back(sumt);


	//	Create a list of static attributes
	create_static_attribute_list(get_class_attr()->get_attr_list());

	/*----- PROTECTED REGION ID(LiberaSinglePassE::Class::attribute_factory_after) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	LiberaSinglePassE::Class::attribute_factory_after

}


//--------------------------------------------------------
/**
 *	Method      : LiberaSinglePassE::LiberaSinglePassEClass::command_factory()
 *	Description : Create the command object(s)
 *	              and store them in the command list
 */
//--------------------------------------------------------
void LiberaSinglePassEClass::command_factory()
{
	/*----- PROTECTED REGION ID(LiberaSinglePassE::Class::command_factory_before) ENABLED START -----*/

	/*----- PROTECTED REGION END -----*/	//	LiberaSinglePassE::Class::command_factory_before

	ResetClass	*pResetCmd =
		new ResetClass("Reset",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	pResetCmd->set_polling_period(0);
	command_list.push_back(pResetCmd);
	ResetTriggerClass	*pResetTriggerCmd =
		new ResetTriggerClass("ResetTrigger",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::EXPERT);
	pResetTriggerCmd->set_polling_period(0);
	command_list.push_back(pResetTriggerCmd);
	ResetInterlockStatusClass	*pResetInterlockStatusCmd =
		new ResetInterlockStatusClass("ResetInterlockStatus",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::EXPERT);
	command_list.push_back(pResetInterlockStatusCmd);
	MagicCommandClass	*pMagicCommandCmd =
		new MagicCommandClass("MagicCommand",
			Tango::DEV_STRING, Tango::DEVVAR_STRINGARRAY,
			"",
			"",
			Tango::EXPERT);
	command_list.push_back(pMagicCommandCmd);

	/*----- PROTECTED REGION ID(LiberaSinglePassE::Class::command_factory_after) ENABLED START -----*/

	/*----- PROTECTED REGION END -----*/	//	LiberaSinglePassE::Class::command_factory_after

}




//===================================================================
//	Dynamic attributes related methods
//===================================================================


//--------------------------------------------------------
/**
 * method : 		LiberaSinglePassEClass::create_static_attribute_list
 * description : 	Create the a list of static attributes
 *
 * @param	att_list	the ceated attribute list
 */
//--------------------------------------------------------
void LiberaSinglePassEClass::create_static_attribute_list(vector<Tango::Attr *> &att_list)
{
	for (unsigned long i=0 ; i<att_list.size() ; i++)
	{
		string att_name(att_list[i]->get_name());
		transform(att_name.begin(), att_name.end(), att_name.begin(), ::tolower);
		defaultAttList.push_back(att_name);
	}

	cout2 << defaultAttList.size() << " attributes in default list" << endl;


	/*----- PROTECTED REGION ID(LiberaSinglePassE::Class::create_static_att_list) ENABLED START -----*/

	/*----- PROTECTED REGION END -----*/	//	LiberaSinglePassE::Class::create_static_att_list

}


//--------------------------------------------------------
/**
 * method : 		LiberaSinglePassEClass::erase_dynamic_attributes
 * description : 	delete the dynamic attributes if any.
 *
 * @param	devlist_ptr	the device list pointer
 * @param	list of all attributes
 */
//--------------------------------------------------------
void LiberaSinglePassEClass::erase_dynamic_attributes(const Tango::DevVarStringArray *devlist_ptr, vector<Tango::Attr *> &att_list)
{
	Tango::Util *tg = Tango::Util::instance();

	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		Tango::DeviceImpl *dev_impl = tg->get_device_by_name(((string)(*devlist_ptr)[i]).c_str());
		LiberaSinglePassE *dev = static_cast<LiberaSinglePassE *> (dev_impl);

		vector<Tango::Attribute *> &dev_att_list = dev->get_device_attr()->get_attribute_list();
		vector<Tango::Attribute *>::iterator ite_att;
		for (ite_att=dev_att_list.begin() ; ite_att != dev_att_list.end() ; ++ite_att)
		{
			string att_name((*ite_att)->get_name_lower());
			if ((att_name == "state") || (att_name == "status"))
				continue;
			vector<string>::iterator ite_str = find(defaultAttList.begin(), defaultAttList.end(), att_name);
			if (ite_str == defaultAttList.end())
			{
				cout2 << att_name << " is a UNWANTED dynamic attribute for device " << (*devlist_ptr)[i] << endl;
				Tango::Attribute &att = dev->get_device_attr()->get_attr_by_name(att_name.c_str());
				dev->remove_attribute(att_list[att.get_attr_idx()],true);
				--ite_att;
			}
		}
	}
	/*----- PROTECTED REGION ID(LiberaSinglePassE::Class::erase_dynamic_attributes) ENABLED START -----*/

	/*----- PROTECTED REGION END -----*/	//	LiberaSinglePassE::Class::erase_dynamic_attributes

}



	/*----- PROTECTED REGION ID(LiberaSinglePassE::Class::Additional Methods) ENABLED START -----*/

	/*----- PROTECTED REGION END -----*/	//	LiberaSinglePassE::Class::Additional Methods

} //	namespace
